{"pages":[{"title":"","text":"cuzz’s blog由Hexo强力驱动，托管在github，采用next主题","link":"/README.html"},{"title":"404","text":"","link":"/404/index.html"},{"title":"","text":"","link":"/tags/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"关于","text":"自我介绍联系我： 微信：cuzz_2020 邮箱：cuzz1234@163.com","link":"/about/index.html"}],"posts":[{"title":"Boom Lab","text":"前言CSAPP 这本书买了好几年，最近抽出一些时间开始重头读这本书，发现这些基础知识比较重要，边看书边跟着视频课程过了一遍，有些东西还是比较模糊。本文开始做 CSAPP Lab 实验，加强巩固书的内容。","link":"/2020/10/20/CSAPP_Boom_Lab/"},{"title":"Spring 的复杂类型注入","text":"Spring 的类型注入先定义一个接口： public interface Animal {} 对应的有一些实现类： @Componentpublic class Dog implements Animal {}@Component(&quot;myCat&quot;)public class Cat implements Animal {} 我们用 Spring 比较常见的用类型注入和名称注入： @Resourceprivate Dog dog; // 按类型注入@Resource(&quot;myCat&quot;)private Cat myCat; // 按名称注入 然后今天在公司看到同事使用观察者模式的时候，使用了另外一种注入方式，注入的是List&lt;XXX&gt;： @Resourceprivate List&lt;Animal&gt; animalList; 这个时候注入的时候实现 Animal 这个接口的所有实现类 Spring 按类型自动注入Array、List、Set、MapSpring 按类型不仅仅注入类本身的，而且还可以注入Array、List、Set 和 Map 。 @Resourceprivate Animal[] animalArr;@Resourceprivate List&lt;Animal&gt; animalList;@Resourceprivate Set&lt;Animal&gt; animalSet;@Resourceprivate Map&lt;String, Animal&gt; animalMap; 我们写一个测试类看看： @Autowiredprivate void print() { System.out.println(Arrays.toString(animalArr)); System.out.println(animalList); System.out.println(animalSet); System.out.println(animalMap);} 发现输出： [com.cuzz.spring.impl.Cat@58cd06cb, com.cuzz.spring.impl.Dog@3be8821f][com.cuzz.spring.impl.Cat@58cd06cb, com.cuzz.spring.impl.Dog@3be8821f][com.cuzz.spring.impl.Cat@58cd06cb, com.cuzz.spring.impl.Dog@3be8821f]{myCat=com.cuzz.spring.impl.Cat@58cd06cb, dog=com.cuzz.spring.impl.Dog@3be8821f} 当为数组和集合的时候会把所有接口的实现类放入其中，当为 Map 时，key 对应的是 Bean 的名称，value 对应Bean。 源码分析先定位到这个方法org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency resolveDependency 方法中定位到根据类型查找依赖 doResolveDependency。 @Override@Nullablepublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { // ... Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) { result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); } return result; }} doResolveDependency 封装了依赖查找的各种情况，我们主要看 resolveMultipleBeans 方法。 @Nullablepublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor); try { // ... // 集合依赖，如 Array、List、Set、Map。 Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) { return multipleBeans; } // ... }} 最终调用resolveMultipleBeans方法 private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) { Class&lt;?&gt; type = descriptor.getDependencyType(); // Stream 类型 if (descriptor instanceof StreamDependencyDescriptor) { Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } Stream&lt;Object&gt; stream = matchingBeans.keySet().stream() .map(name -&gt; descriptor.resolveCandidate(name, type, this)) .filter(bean -&gt; !(bean instanceof NullBean)); if (((StreamDependencyDescriptor) descriptor).isOrdered()) { stream = stream.sorted(adaptOrderComparator(matchingBeans)); } return stream; } // Array else if (type.isArray()) { Class&lt;?&gt; componentType = type.getComponentType(); ResolvableType resolvableType = descriptor.getResolvableType(); Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type); if (resolvedArrayType != type) { componentType = resolvableType.getComponentType().resolve(); } if (componentType == null) { return null; } Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType); if (result instanceof Object[]) { Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans); if (comparator != null) { Arrays.sort((Object[]) result, comparator); } } return result; } // 集合 else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) { Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric(); if (elementType == null) { return null; } Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), type); if (result instanceof List) { if (((List&lt;?&gt;) result).size() &gt; 1) { Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans); if (comparator != null) { ((List&lt;?&gt;) result).sort(comparator); } } } return result; } // Map else if (Map.class == type) { ResolvableType mapType = descriptor.getResolvableType().asMap(); Class&lt;?&gt; keyType = mapType.resolveGeneric(0); if (String.class != keyType) { return null; } Class&lt;?&gt; valueType = mapType.resolveGeneric(1); if (valueType == null) { return null; } Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } return matchingBeans; } else { return null; }} 从源码发现，不仅仅可以注入数组、集合和Map，还可以注入 Stream。 总结Spring按类型注入不仅仅注入简单的Bean，还可以注入一些数组、集合、Map 以及 Stream。 如果想进一步了解这一块可以看看这篇文章Spring IoC 依赖注入（三）resolveDependency","link":"/2020/09/29/Spring%20%E7%9A%84%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"},{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"}]}